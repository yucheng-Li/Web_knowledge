<!DOCTYPE html>
<!-- saved from url=(0038)https://zhuanlan.zhihu.com/p/130905785 -->
<html lang="zh" data-hairline="true" data-theme="light" data-react-helmet="data-theme"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>😀前端入门操作系统知识，这一篇就够啦！ - 知乎</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="google-site-verification" content="FTeR0c8arOPKh8c5DYh_9uu98_zJbaWw53J-Sch9MTg"><meta data-react-helmet="true" name="keywords" content="前端入门,程序员,前端开发"><meta data-react-helmet="true" name="description" content="此文针对非科班同学来补充程序猿必备的基础知识。 不凡学院： 前端需要了解的计算机网络知识， 这一篇就够了！(图文并茂，万字长文，点赞收藏哦！)不凡学院：【非科班前端】注意了！ 计算机组成原理知识已送到你嘴…"><meta data-react-helmet="true" property="og:title" content="😀前端入门操作系统知识，这一篇就够啦！"><meta data-react-helmet="true" property="og:url" content="https://zhuanlan.zhihu.com/p/130905785"><meta data-react-helmet="true" property="og:description" content="此文针对非科班同学来补充程序猿必备的基础知识。 不凡学院： 前端需要了解的计算机网络知识， 这一篇就够了！(图文并茂，万字长文，点赞收藏哦！)不凡学院：【非科班前端】注意了！ 计算机组成原理知识已送到你嘴…"><meta data-react-helmet="true" property="og:image" content=""><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="og:site_name" content="知乎专栏"><link data-react-helmet="true" rel="apple-touch-icon" href="https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.67c7b278.png"><link data-react-helmet="true" rel="apple-touch-icon" href="https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.67c7b278.png" sizes="152x152"><link data-react-helmet="true" rel="apple-touch-icon" href="https://static.zhihu.com/heifetz/assets/apple-touch-icon-120.b3e6278d.png" sizes="120x120"><link data-react-helmet="true" rel="apple-touch-icon" href="https://static.zhihu.com/heifetz/assets/apple-touch-icon-76.7a750095.png" sizes="76x76"><link data-react-helmet="true" rel="apple-touch-icon" href="https://static.zhihu.com/heifetz/assets/apple-touch-icon-60.a4a761d4.png" sizes="60x60"><link rel="shortcut icon" type="image/x-icon" href="https://static.zhihu.com/static/favicon.ico"><link rel="search" type="application/opensearchdescription+xml" href="https://static.zhihu.com/static/search.xml" title="知乎"><link rel="dns-prefetch" href="https://static.zhimg.com/"><link rel="dns-prefetch" href="https://pic1.zhimg.com/"><link rel="dns-prefetch" href="https://pic2.zhimg.com/"><link rel="dns-prefetch" href="https://pic3.zhimg.com/"><link rel="dns-prefetch" href="https://pic4.zhimg.com/"><style>
.u-safeAreaInset-top {
  height: constant(safe-area-inset-top) !important;
  height: env(safe-area-inset-top) !important;
  
}
.u-safeAreaInset-bottom {
  height: constant(safe-area-inset-bottom) !important;
  height: env(safe-area-inset-bottom) !important;
  
}
</style><link href="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/column.app.216a26f4.1eca477cc6018aa2f674.css" rel="stylesheet"><script defer="" crossorigin="anonymous" src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/init.js.下载" data-sentry-config="{&quot;dsn&quot;:&quot;https://2d8d764432cc4f6fb3bc78ab9528299d@crash2.zhihu.com/1224&quot;,&quot;sampleRate&quot;:0.1,&quot;release&quot;:&quot;502-3162490a&quot;,&quot;ignoreErrorNames&quot;:[&quot;NetworkError&quot;,&quot;SecurityError&quot;],&quot;ignoreErrors&quot;:[&quot;origin message&quot;,&quot;Network request failed&quot;,&quot;Loading chunk&quot;,&quot;这个系统不支持该功能。&quot;,&quot;Can&#39;t find variable: webkit&quot;,&quot;Can&#39;t find variable: $&quot;,&quot;内存不足&quot;,&quot;out of memory&quot;,&quot;DOM Exception 18&quot;,&quot;The operation is insecure&quot;,&quot;[object Event]&quot;,&quot;[object FileError]&quot;,&quot;[object DOMError]&quot;,&quot;[object Object]&quot;,&quot;拒绝访问。&quot;,&quot;Maximum call stack size exceeded&quot;,&quot;UploadError&quot;,&quot;无法 fetch&quot;,&quot;draft-js&quot;,&quot;缺少 JavaScript 对象&quot;,&quot;componentWillEnter&quot;,&quot;componentWillLeave&quot;,&quot;componentWillAppear&quot;,&quot;getInlineStyleAt&quot;,&quot;getCharacterList&quot;],&quot;whitelistUrls&quot;:[&quot;static.zhihu.com&quot;]}"></script><style data-emotion-css="1cd9gw4">.css-1cd9gw4{margin-left:.3em;}</style><style data-emotion-css="n99yhz">.css-n99yhz{box-sizing:border-box;margin:0;min-width:0;color:#175199;display:inline-block;margin-left:.3em;}</style><style data-emotion-css="18biwo">.css-18biwo{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><style data-emotion-css="1ifz0go">.css-1ifz0go{overflow:visible!important;}</style><script charset="utf-8" src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/column.zswsdid.2413fe7430c062b6b075.js.下载"></script><link rel="stylesheet" type="text/css" href="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/column.user-hover-card.216a26f4.7da9107a14dfae975315.css"><script charset="utf-8" src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/column.user-hover-card.f9a133fa39ee8074575b.js.下载"></script><link rel="stylesheet" type="text/css" href="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/column.Labels.216a26f4.3b0495fb65d20aa3460e.css"><script charset="utf-8" src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/column.Labels.8eeeef82f0187ef02bf8.js.下载"></script><link rel="stylesheet" type="text/css" href="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/column.modals.216a26f4.3a035d6e2ac18e2fd358.css"><script charset="utf-8" src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/column.modals.164ea834572ef55e6da0.js.下载"></script><style data-emotion="css"></style><link rel="stylesheet" type="text/css" href="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/column.richinput.216a26f4.39ebd4d60ca2ec2e3d70.css"><script charset="utf-8" src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/column.richinput.fd6946878c9a6d282c1c.js.下载"></script></head><body class="WhiteBg-body" data-react-helmet="class"><div id="root"><div class="App"><div class="LoadingBar"></div><main role="main" class="App-main"><div class="Post-content" data-zop-usertoken="{&quot;userToken&quot;:&quot;yu-cheng-ren-47&quot;}" data-zop="{&quot;authorName&quot;:&quot;不凡学院&quot;,&quot;itemId&quot;:130905785,&quot;title&quot;:&quot;😀前端入门操作系统知识，这一篇就够啦！&quot;,&quot;type&quot;:&quot;article&quot;}" data-za-detail-view-path-module="PostItem" data-za-extra-module="{&quot;card&quot;:{&quot;content&quot;:{&quot;type&quot;:&quot;Post&quot;,&quot;token&quot;:&quot;130905785&quot;}}}"><div class="ColumnPageHeader-Wrapper"><div><div class="Sticky ColumnPageHeader is-fixed" style="width: 1519.2px; top: 0px; left: 0px;"><div class="ColumnPageHeader-content"><a href="https://www.zhihu.com/" aria-label="知乎"><svg viewBox="0 0 200 91" fill="#0084FF" width="64" height="30"><path d="M53.29 80.035l7.32.002 2.41 8.24 13.128-8.24h15.477v-67.98H53.29v67.978zm7.79-60.598h22.756v53.22h-8.73l-8.718 5.473-1.587-5.46-3.72-.012v-53.22zM46.818 43.162h-16.35c.545-8.467.687-16.12.687-22.955h15.987s.615-7.05-2.68-6.97H16.807c1.09-4.1 2.46-8.332 4.1-12.708 0 0-7.523 0-10.085 6.74-1.06 2.78-4.128 13.48-9.592 24.41 1.84-.2 7.927-.37 11.512-6.94.66-1.84.785-2.08 1.605-4.54h9.02c0 3.28-.374 20.9-.526 22.95H6.51c-3.67 0-4.863 7.38-4.863 7.38H22.14C20.765 66.11 13.385 79.24 0 89.62c6.403 1.828 12.784-.29 15.937-3.094 0 0 7.182-6.53 11.12-21.64L43.92 85.18s2.473-8.402-.388-12.496c-2.37-2.788-8.768-10.33-11.496-13.064l-4.57 3.627c1.363-4.368 2.183-8.61 2.46-12.71H49.19s-.027-7.38-2.372-7.38zm128.752-.502c6.51-8.013 14.054-18.302 14.054-18.302s-5.827-4.625-8.556-1.27c-1.874 2.548-11.51 15.063-11.51 15.063l6.012 4.51zm-46.903-18.462c-2.814-2.577-8.096.667-8.096.667s12.35 17.2 12.85 17.953l6.08-4.29s-8.02-11.752-10.83-14.33zM199.99 46.5c-6.18 0-40.908.292-40.953.292v-31.56c1.503 0 3.882-.124 7.14-.376 12.773-.753 21.914-1.25 27.427-1.504 0 0 3.817-8.496-.185-10.45-.96-.37-7.24 1.43-7.24 1.43s-51.63 5.153-72.61 5.64c.5 2.756 2.38 5.336 4.93 6.11 4.16 1.087 7.09.53 15.36.277 7.76-.5 13.65-.76 17.66-.76v31.19h-41.71s.88 6.97 7.97 7.14h33.73v22.16c0 4.364-3.498 6.87-7.65 6.6-4.4.034-8.15-.36-13.027-.566.623 1.24 1.977 4.496 6.035 6.824 3.087 1.502 5.054 2.053 8.13 2.053 9.237 0 14.27-5.4 14.027-14.16V53.93h38.235c3.026 0 2.72-7.432 2.72-7.432z" fill-rule="evenodd"></path></svg></a><i class="ColumnPageHeader-Line"></i><div class="ColumnPageHeader-Title"><div class="ColumnPageHeader-TitleName"><span class="ColumnPageHeader-TitleMeta">首发于</span><a class="ColumnLink ColumnPageHeader-TitleColumn" href="https://www.zhihu.com/column/c_1212785891581743104">前端转行指南</a></div></div><div class="ColumnPageHeader-Button"><button type="button" class="Button ColumnPageHeader-WriteButton Button--blue"><svg class="Zi Zi--EditSurround" fill="currentColor" viewBox="0 0 24 24" width="24" height="24"><path d="M18.453 7.992l-1.833-1.65.964-.978a1.223 1.223 0 0 1 1.73-.012l.005.006a1.24 1.24 0 0 1 .007 1.748l-.873.886zm-1.178 1.194l-5.578 5.66-1.935.697a.393.393 0 0 1-.504-.504l.697-1.935 5.488-5.567 1.832 1.65zM7.58 5.848l5.654.006-1.539 1.991-3.666.012A1.02 1.02 0 0 0 7 8.868v7.993c0 .558.46 1.01 1.029 1.01l7.941-.01c.568 0 1.03-.453 1.03-1.012v-4.061l2-1.442v6.002c0 1.397-1.2 2.501-2.62 2.501H7.574C6.153 19.85 5 18.717 5 17.32V8.35c0-1.397 1.16-2.502 2.58-2.502z"></path></svg>写文章</button><div class="Popover"><button title="更多" id="Popover1-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover1-content" type="button" class="Button ColumnPageHeader-MenuToggler Button--plain"><svg class="Zi Zi--Dots" fill="currentColor" viewBox="0 0 24 24" width="24" height="24"><path d="M5 14a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm7 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm7 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4z" fill-rule="evenodd"></path></svg></button></div></div></div></div><div class="Sticky--holder" style="position: relative; top: 0px; right: 0px; bottom: 0px; left: 0px; display: block; float: none; margin: 0px; height: 52px;"></div></div></div><article class="Post-Main Post-NormalMain" tabindex="-1"><header class="Post-Header"><h1 class="Post-Title">😀前端入门操作系统知识，这一篇就够啦！</h1><div class="Post-Author"><div class="AuthorInfo" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="不凡学院"><meta itemprop="image" content="https://pic2.zhimg.com/v2-2f9551216fc17270ec6eeaecad8999d3_l.jpg?source=172ae18b"><meta itemprop="url" content="https://www.zhihu.com/people/bu-fan-xue-yuan-34"><meta itemprop="zhihu:followerCount"><span class="UserLink AuthorInfo-avatarWrapper"><div class="Popover"><div id="Popover9-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover9-content"><a class="UserLink-link" data-za-detail-view-element_name="User" target="_blank" href="https://www.zhihu.com/org/bu-fan-xue-yuan-34"><img class="Avatar Avatar--round AuthorInfo-avatar" width="38" height="38" src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-2f9551216fc17270ec6eeaecad8999d3_xs.jpg" srcset="https://pic2.zhimg.com/v2-2f9551216fc17270ec6eeaecad8999d3_l.jpg?source=172ae18b 2x" alt="不凡学院"></a></div></div></span><div class="AuthorInfo-content"><div class="AuthorInfo-head"><span class="UserLink AuthorInfo-name"><div class="Popover"><div id="Popover10-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover10-content"><a class="UserLink-link" data-za-detail-view-element_name="User" target="_blank" href="https://www.zhihu.com/org/bu-fan-xue-yuan-34">不凡学院</a></div></div><a href="https://www.zhihu.com/question/48510028" target="_blank" class="css-n99yhz" aria-label="已认证的官方帐号" data-tooltip="已认证的官方帐号"><span class="css-18biwo">​<svg viewBox="0 0 24 24" class="css-1ifz0go" width="18" height="18"><svg viewBox="0 0 24 24" x="-3" y="-3" fill="#FFFFFF" width="30" height="30"><path d="M3.56231227,13.8535307 C2.40051305,12.768677 2.41398885,11.0669203 3.59484487,9.99979213 L3.59222085,9.99654885 C4.26730143,9.45036719 4.79446755,8.21005186 4.7184197,7.34453784 L4.72305873,7.34412719 C4.66942824,5.75539997 5.8824188,4.56066914 7.47188965,4.64242381 L7.47229112,4.6386236 C8.33515314,4.72977993 9.58467253,4.22534048 10.1426329,3.55925173 L10.1462611,3.56228565 C11.2316055,2.40008701 12.9353108,2.41394456 14.0015072,3.59634088 L14.0047263,3.59374004 C14.5498229,4.26841874 15.7896857,4.79521622 16.6545744,4.71844347 L16.6549836,4.72304294 C18.245027,4.66894057 19.4396947,5.88213996 19.3575031,7.47241135 L19.3623099,7.47292747 C19.2704388,8.3358681 19.7742711,9.58421483 20.4407199,10.1424506 L20.437686,10.1460789 C21.5997217,11.2312209 21.5860695,12.9345218 20.4042441,14.0007396 L20.4072865,14.0045125 C19.7325967,14.5495925 19.2055209,15.7896954 19.2815865,16.6561959 L19.2770449,16.6565978 C19.3315454,18.2453037 18.1173775,19.4393568 16.5274188,19.3571512 L16.5269029,19.3619539 C15.6647098,19.270083 14.415408,19.7741709 13.8573671,20.4403558 L13.8537409,20.4373235 C12.76842,21.5995708 11.0650432,21.5864553 9.99899434,20.4039226 L9.99527367,20.406923 C9.45025436,19.7323399 8.21017638,19.2051872 7.34461983,19.2812352 L7.344304,19.2776405 C5.75448683,19.3312904 4.55977145,18.1170085 4.64254978,16.527117 L4.63769921,16.5265942 C4.72957031,15.6644394 4.22547659,14.4151814 3.55928015,13.8571569 L3.56231227,13.8535307 Z"></path></svg><path d="M2.63951518,13.3895441 C3.70763333,14.2842292 4.44777637,16.1226061 4.30075305,17.5023312 L4.32211542,17.3063047 C4.17509209,18.6910561 5.17786655,19.7063729 6.5613937,19.5844846 L6.364106,19.6008202 C7.75140298,19.4789319 9.57474349,20.2554985 10.4468305,21.3349009 L10.3224262,21.1803415 C11.1982831,22.2647703 12.6257916,22.2723098 13.5167278,21.2079863 L13.3898102,21.3600325 C14.2845162,20.2919393 16.1229361,19.5518136 17.5026934,19.6988334 L17.3054057,19.6774716 C18.6914461,19.8244915 19.7067866,18.8217404 19.5836389,17.4395022 L19.6012314,17.6367853 C19.4793403,16.2482641 20.255925,14.4249662 21.3353526,13.5528995 L21.1807897,13.677301 C22.2639871,12.8014646 22.2727834,11.3739894 21.2084351,10.483074 L21.3604848,10.6099886 C20.2923667,9.71530351 19.5522236,7.87818322 19.6992469,6.49720154 L19.6778846,6.69448464 C19.8249079,5.30847665 18.8221335,4.2944164 17.4386063,4.41630468 L17.635894,4.39871256 C16.248597,4.52185742 14.4252565,3.74529084 13.5531695,2.66588842 L13.6775738,2.81919121 C12.8017169,1.73601905 11.3742084,1.72722299 10.4832722,2.79154644 L10.6101898,2.63950024 C9.71548377,3.70759343 7.87706394,4.44771919 6.49730661,4.30195588 L6.69459432,4.32206116 C5.30855394,4.17504128 4.29447,5.17904888 4.41636114,6.56128713 L4.3987686,6.36400404 C4.52065973,7.75126861 3.74407501,9.57456653 2.66464737,10.4478898 L2.81921035,10.3222318 C1.73601288,11.1993248 1.72721662,12.6255433 2.79156494,13.5164587 L2.63951518,13.3895441 Z" fill="#0084FF"></path><svg class="Zi Zi--Check" fill="#fff" x="6" y="6" viewBox="0 0 24 24" width="12" height="12"><path d="M10.229 17.516c-.318.327-.75.484-1.199.484-.453 0-.884-.16-1.202-.488l-4.335-4.47a1.77 1.77 0 0 1 .007-2.459 1.663 1.663 0 0 1 2.397.01l3.137 3.246 9.072-9.329a1.662 1.662 0 0 1 2.397 0c.663.681.663 1.786 0 2.466L10.23 17.516z" fill-rule="evenodd"></path></svg></svg></span></a></span></div><div class="AuthorInfo-detail"><div class="AuthorInfo-badge"><div class="ztext AuthorInfo-badgeText">已认证的官方帐号</div></div></div></div></div><button type="button" class="Button FollowButton Button--primary Button--blue"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--Plus FollowButton-icon" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M13.491 10.488s-.012-5.387 0-5.998c-.037-1.987-3.035-1.987-2.997 0-.038 1.912 0 5.998 0 5.998H4.499c-1.999.01-1.999 3.009 0 3.009s5.995-.01 5.995-.01v5.999c0 2.019 3.006 2.019 2.997 0-.01-2.019 0-5.998 0-5.998s3.996.009 6.004.009c2.008 0 2.008-3-.01-3.009h-5.994z" fill-rule="evenodd"></path></svg></span>关注他</button></div><div><span class="Voters"><button type="button" class="Button Button--plain">2 人<!-- -->赞同了该文章</button></span></div></header><div class="Post-RichTextContainer"><div class="RichText ztext Post-RichText"><p>此文针对非科班同学来补充程序猿必备的基础知识。<br> </p><a target="_blank" href="https://zhuanlan.zhihu.com/p/112777391" data-draft-node="block" data-draft-type="link-card" data-image="https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg" class="LinkCard LinkCard--hasImage" data-za-detail-view-id="172"><span class="LinkCard-backdrop" style="background-image:url(https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg)"></span><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">不凡学院： 前端需要了解的计算机网络知识， 这一篇就够了！(图文并茂，万字长文，点赞收藏哦！)</span><span class="LinkCard-meta"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>zhuanlan.zhihu.com</span></span><span class="LinkCard-imageCell"><img class="LinkCard-image LinkCard-image--square" alt="图标" src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/zhihu-card-default.svg"></span></span></a><a target="_blank" href="https://zhuanlan.zhihu.com/p/112514996" data-draft-node="block" data-draft-type="link-card" data-image="https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg" class="LinkCard LinkCard--hasImage" data-za-detail-view-id="172"><span class="LinkCard-backdrop" style="background-image:url(https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg)"></span><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">不凡学院：【非科班前端】注意了！ 计算机组成原理知识已送到你嘴边!</span><span class="LinkCard-meta"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>zhuanlan.zhihu.com</span></span><span class="LinkCard-imageCell"><img class="LinkCard-image LinkCard-image--square" alt="图标" src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/zhihu-card-default.svg"></span></span></a><p><br> </p><p> 好了，开撸操作系统！<br> <br></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-2cf128731dfb1c8ebd23d2b0e3fcaec4_b.jpg" data-caption="" data-size="normal" data-rawwidth="177" data-rawheight="163" class="content_image" width="177"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-2cf128731dfb1c8ebd23d2b0e3fcaec4_720w.jpg" data-caption="" data-size="normal" data-rawwidth="177" data-rawheight="163" class="content_image lazy" width="177" data-actualsrc="https://pic3.zhimg.com/v2-2cf128731dfb1c8ebd23d2b0e3fcaec4_b.jpg" data-lazy-status="ok"></figure><p><b>弱弱的问一问: 要操作系统干嘛？</b></p><p>这里先不讲<code>操作系统</code>的概念了，因为文字太生硬了，我们只需要看一个简单的例子：</p><ul><li>在我们的JS代码里，只需要输入 <code>console.log(1+1)</code>; 就可以在浏览器面板中看到<code>2</code>，这其中发生了什么事情呢?(简单扫一眼)</li><li>首先键盘输入代码<code>1+1</code>到显示器输出<code>2</code>, 需要<code>CPU</code>控制键盘（输入设备） ，将获取的<code>1+1</code>指令放入内存</li><li>然后CPU的控制器从内存中取出指令，并分析出指令是让计算机做一个<code>1+1</code>的加法运算</li><li>此时CPU的控制将控制CPU的运算器做<code>1+1</code>的加法运算，并得出结果<code>2</code></li><li>最后CPU控制器控制运算器将结果返给内存，内存也在CPU控制器的控制下，将结果<code>2</code>返回给屏幕（输出设备）</li></ul><p>好了，这里问题是，如果没有操作系统，一个简单的1+1运算，你的js代码还需要考虑这些硬件的协调工作，比如你的代码要协调CPU资源什么时候读取你的代码，什么时候把进程切换到别的进程。。。这些脏活累活都是操作系统帮你屏蔽了，要不这代码可咋写啊。。。<br> <br></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-3d7bf71428d8ce8371652bb4c52a01a1_b.jpg" data-caption="" data-size="normal" data-rawwidth="590" data-rawheight="509" class="origin_image zh-lightbox-thumb" width="590" data-original="https://pic3.zhimg.com/v2-3d7bf71428d8ce8371652bb4c52a01a1_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-3d7bf71428d8ce8371652bb4c52a01a1_720w.jpg" data-caption="" data-size="normal" data-rawwidth="590" data-rawheight="509" class="origin_image zh-lightbox-thumb lazy" width="590" data-original="https://pic3.zhimg.com/v2-3d7bf71428d8ce8371652bb4c52a01a1_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-3d7bf71428d8ce8371652bb4c52a01a1_b.jpg" data-lazy-status="ok"></figure><p>弱弱的问一问: 前端学这个干嘛？</p><p>很早以前看朴零大神的《深入浅出NodeJS》的时候，讲到进程间通信，有一句大概说，windows平台进程间通信用的是管道，linux平台用的是domain socket，我一看就傻眼了，啥是进程间通信？啥是管道？啥是domain socket？  看不懂啊....  这些都是跟操作系统进程的知识相关）。</p><p>啥也了不说了，兄弟，学习的小车已经粗发了！<br> <br></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-fe4d84f07dadfa898c023c92586a5d8a_b.jpg" data-caption="" data-size="normal" data-rawwidth="845" data-rawheight="450" class="origin_image zh-lightbox-thumb" width="845" data-original="https://pic2.zhimg.com/v2-fe4d84f07dadfa898c023c92586a5d8a_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-fe4d84f07dadfa898c023c92586a5d8a_720w.jpg" data-caption="" data-size="normal" data-rawwidth="845" data-rawheight="450" class="origin_image zh-lightbox-thumb lazy" width="845" data-original="https://pic2.zhimg.com/v2-fe4d84f07dadfa898c023c92586a5d8a_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-fe4d84f07dadfa898c023c92586a5d8a_b.jpg" data-lazy-status="ok"></figure><p><b>1、操作系统的四个特征</b></p><p>有以下四个特征：</p><ul><li>并发</li><li>共享</li><li>虚拟</li><li>异步</li></ul><p> 接下来，我们分别来搞定每一个特征。</p><p><b>1.1 并发是什么？和并行有啥区别？</b></p><p>举个例子，假如你在语音跟同学玩英雄联盟：</p><ul><li>你一边用鼠标移动打游戏，同时语音嘴里说"队友挂机，真坑！", 这叫并行（边移动鼠标边语音BB）</li><li>你一边用鼠标移动打游戏，然后离开鼠标，去砸键盘, 这叫并发（先离开鼠标然后砸键盘</li></ul><p>并发只是把时间分成若干段，<code>使多个任务交替的执行</code>。 并行的关键是你有<code>同时处理</code>多个任务的能力。<br> </p><ul><li>所以我认为它们最关键的点就是：<code>是否是『同时』</code></li></ul><p>那么对于操作系统而言，操作系统的并发性指计算机系统中<code>同时存在多个运行着的程序</code>。<br> </p><ul><li> 比如说以前的计算机是单核CPU，那么如何在操作系统上同时运行QQ、浏览器，记事本、ppt等多个程序呢，这就需要操作系统具有并发性<br> </li><li><code>CPU时间</code>片（操作系统分配给每个正在运行的进程微观上的一段CPU时间）轮着给进程执行的时间，因为执行速度很快，<code>看起来就像</code>浏览器能同时执行任务一样。<br> </li><li> 有人会说，现在都多核CPU了，还需要并发吗，答案肯定是需要的，比如你有8核CPU，但是桌面要执行的任务很可能超过8个。</li></ul><p><b>1.2 共享是什么？共享和并发有什么关系？</b></p><p>举一个例子： 你同时用QQ和微信发"年终述职.ppt"文件给领导，这时候QQ和微信都在读取这个ppt文件</p><ul><li>两个进程正在并发执行（并发性）</li><li>需要共享地访问硬盘资源（共享性） 如果没有并发，也就是只有一个进程在运行，那就没有共享了。如果没有共享，QQ和微信就不能同时发文件，无法同时访问硬盘资源，也就无法并发。</li></ul><p>其中共享分为两种情况：<br> <br></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-06bcbe0251301f0c15f1afd61d50aaa8_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="325" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic4.zhimg.com/v2-06bcbe0251301f0c15f1afd61d50aaa8_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-06bcbe0251301f0c15f1afd61d50aaa8_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="325" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic4.zhimg.com/v2-06bcbe0251301f0c15f1afd61d50aaa8_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-06bcbe0251301f0c15f1afd61d50aaa8_b.jpg" data-lazy-status="ok"></figure><p><br> </p><ul><li>上面的例子，QQ和微信都要访问同一个文件，属于<code>同时共享</code>。</li><li>对于互斥共享，比如打印机，<code>只能同一时刻被一个进程控制</code>，如打印机，虽然他可以提供多个进程使用，但是试想，同时打印多个东西，会造成打印结果的混乱，因此规定，某些资源在进行使用的时候，必须要先让某进程先使用，等使用完之后，再同一其他进程进行访问。</li><li>我们把一段时间内只允许一个进程访问的资源称为<code>独占资源</code>，或<code>临界资源</code>。</li></ul><p><b>1.3 虚拟是啥？</b></p><p>先举例，再说定义。</p><p>假如一个叫<code>范桶</code>的货车司机在玩英雄联盟，平时因为酒驾太多，自己装了很多次别人的车，住院也花了不少钱，所以家里没钱，只能买个<code>1G内存</code>的二手电脑玩游戏。可<code>英雄联盟</code>至少需要<code>2G内存</code>，这就奇怪了，老司机虽然一到团战就卡死，但是还是能运行英雄联盟。为什么需要<code>2G内存</code>的游戏，<code>1G电脑</code>还能运行呢？<br> <br></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-e4612e1924920eda9b8eaa5b2d1691f8_b.jpg" data-caption="" data-size="normal" data-rawwidth="500" data-rawheight="492" class="origin_image zh-lightbox-thumb" width="500" data-original="https://picb.zhimg.com/v2-e4612e1924920eda9b8eaa5b2d1691f8_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-e4612e1924920eda9b8eaa5b2d1691f8_720w.jpg" data-caption="" data-size="normal" data-rawwidth="500" data-rawheight="492" class="origin_image zh-lightbox-thumb lazy" width="500" data-original="https://picb.zhimg.com/v2-e4612e1924920eda9b8eaa5b2d1691f8_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-e4612e1924920eda9b8eaa5b2d1691f8_b.jpg" data-lazy-status="ok"></figure><p>这就是虚拟存储器技术。实际上<code>只有1G内存</code>，在用户看来<code>远远大于1G</code>。</p><p>还有，<code>范桶</code>的电脑还是<code>单核的</code>，但<code>范桶</code>居然能一边迅雷下着爱情动作片，一边听着网易云音乐，还在QQ上撩妹子，既然一个程序要被分配CPU才能正常执行，按道理来说同一时间只有1个程序在运行，为啥电脑能同时运行这么多程序呢？</p><p>这就是虚拟处理器技术。实际上只有<code>一个CPU</code>，在用户看来有<code>3个CPU</code>在同时服务。（因为CPU来回切换进程的速度特别块，感觉就像很多CPU在为我们服务）</p><p>虚拟这块的总结如下:<br> <br></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-4b1a275914866d978473d169c72b439a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1269" data-rawheight="489" class="origin_image zh-lightbox-thumb" width="1269" data-original="https://pic3.zhimg.com/v2-4b1a275914866d978473d169c72b439a_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-4b1a275914866d978473d169c72b439a_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1269" data-rawheight="489" class="origin_image zh-lightbox-thumb lazy" width="1269" data-original="https://pic3.zhimg.com/v2-4b1a275914866d978473d169c72b439a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-4b1a275914866d978473d169c72b439a_b.jpg" data-lazy-status="ok"></figure><p><b>1.4 异步性是啥?</b></p><p>异步在JS里是很常见的，比如<code>ajax请</code>求，我们发出请求后并不是立马得到信息，也不会去等待<code>ajax</code>结果返回，而是继续执行下面的代码，等ajax结果回来，通知<code>JS线程</code>。这就跟<code>CPU处理进程</code>很类似。</p><p>比如，CPU正在执行一个进程，进程需要读取文件，读取文件可能要<code>1个小时</code>，那CPU不可能一直等一个小时，CPU会继续把时间片分给别的进程，等文件读取完成了（类似ajax返回结果了），<code>CPU再继续执行</code>之前被<code>中断</code>的进程。</p><p>所以异步性就是描述进程这种以不可预知的速度走走停停、何时开始何时暂停何时结束不可预知的性质。<br><br><b>2、操作系统运行机制和体系结构</b></p><p>预备知识： 什么是指令</p><p>比如说，如下图（简单扫一下即可）：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-b552286ba02148a7cb8babe4af1b4f04_b.jpg" data-caption="" data-size="normal" data-rawwidth="563" data-rawheight="170" class="origin_image zh-lightbox-thumb" width="563" data-original="https://picb.zhimg.com/v2-b552286ba02148a7cb8babe4af1b4f04_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-b552286ba02148a7cb8babe4af1b4f04_720w.jpg" data-caption="" data-size="normal" data-rawwidth="563" data-rawheight="170" class="origin_image zh-lightbox-thumb lazy" width="563" data-original="https://picb.zhimg.com/v2-b552286ba02148a7cb8babe4af1b4f04_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-b552286ba02148a7cb8babe4af1b4f04_b.jpg" data-lazy-status="ok"></figure><p>a+b是一段程序代码，a+b在CPU看来并不能一步完成，可以翻译成如下：</p><div class="highlight"><pre><code class="language-text">// 意思是将内存的16号单元数据，放到A寄存器，
LOAD A, 16
// 意思是将内存的16号单元数据，放到B寄存器
LOAD B, 17
// 存器里的A,B数据相加，得到C
ADD C, A, B
</code></pre></div><p>这里就可以看得出来，指令是<code>CPU</code>能<code>识别</code>和<code>执行</code>的最基本命令。</p><p><b>2.1 两种指令、两种处理器状态、两种程序</b></p><p>假如说一个用户可以随意把服务器上的所有文件删光，这是很危险的。所以有些指令普通用户是不能使用的，只能是<code>权限较高</code>的用户能使用。此时指令就分为了两种，如下图：<br> <br></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-bf6450e944a269b5efef95f1e5eb0364_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="299" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://picb.zhimg.com/v2-bf6450e944a269b5efef95f1e5eb0364_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-bf6450e944a269b5efef95f1e5eb0364_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="299" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://picb.zhimg.com/v2-bf6450e944a269b5efef95f1e5eb0364_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-bf6450e944a269b5efef95f1e5eb0364_b.jpg" data-lazy-status="ok"></figure><p>这就引出一个问题：CPU<code>如何判断</code>当前是否可以执行<code>特权指令</code>？ 如下图: <br></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-97d8a13c43a6d5a513997aad4c793dd1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="293" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://picb.zhimg.com/v2-97d8a13c43a6d5a513997aad4c793dd1_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-97d8a13c43a6d5a513997aad4c793dd1_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="293" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://picb.zhimg.com/v2-97d8a13c43a6d5a513997aad4c793dd1_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-97d8a13c43a6d5a513997aad4c793dd1_b.jpg" data-lazy-status="ok"></figure><p>CPU通常有两种工作模式即：<code>内核态</code>和<code>用户态</code>，而在PSW（这个不用管，就知道有一个寄存器的标志位0表示用户态，1表示核心态）中有一个二进制位控制这两种模式。</p><p>对于应用程序而言，有的程序能执行特权指令，有的程序只能执行非特权指令。所以操作系统里的程序又分为两种：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-005afaad33a3a6f99997ec912225773e_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="422" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic2.zhimg.com/v2-005afaad33a3a6f99997ec912225773e_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-005afaad33a3a6f99997ec912225773e_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="422" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic2.zhimg.com/v2-005afaad33a3a6f99997ec912225773e_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-005afaad33a3a6f99997ec912225773e_b.jpg" data-lazy-status="ok"></figure><p class="ztext-empty-paragraph"><br></p><h3>2.2 操作系统内核简单介绍</h3><p>从下图，我们先看看操作系统内核包含哪些<br> <br></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-74317e6fd6ccab652f5b6747524b58ea_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="465" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic4.zhimg.com/v2-74317e6fd6ccab652f5b6747524b58ea_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-74317e6fd6ccab652f5b6747524b58ea_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="465" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic4.zhimg.com/v2-74317e6fd6ccab652f5b6747524b58ea_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-74317e6fd6ccab652f5b6747524b58ea_b.jpg" data-lazy-status="ok"></figure><p>操作系统内核中跟硬件紧密相关的部分有：</p><ul><li>时钟管理。操作系统的时钟管理是依靠<code>硬件定时器</code>的（具体硬件怎么实现我也不太清楚，好像是靠硬件周期性的产生一个脉冲信号实现的）。时钟管理相当重要，比如我们<code>获取时间信息</code>，<code>进程切换</code>等等都是要依靠时钟管理。</li><li>中断处理（下一小节会详细介绍）。</li><li>原语（后面会有案例提到）。现在可以简单理解为用来实现某个特定功能，在执行过程中<code>不可被中断</code>的指令集合。原语有一个非常重要的特性，就是原子性（其运行<code>一气呵成，不可中断</code>）。</li></ul><p><b> 2.3 中断</b></p><ul><li>在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU<code>暂时中止程序的执行</code>转而<code>处理这个新的情况</code>的过程就叫做<code>中断</code>。 下面举一个例子：</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-8461e2892594360e6cec6d0d1f5c4789_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="573" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic1.zhimg.com/v2-8461e2892594360e6cec6d0d1f5c4789_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-8461e2892594360e6cec6d0d1f5c4789_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="573" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic1.zhimg.com/v2-8461e2892594360e6cec6d0d1f5c4789_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-8461e2892594360e6cec6d0d1f5c4789_b.jpg" data-lazy-status="ok"></figure><p>第一个应用程序在用户态执行了一段时间后 </p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-43cdd9e32d0d61174d8f914ff4280ccb_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="556" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic4.zhimg.com/v2-43cdd9e32d0d61174d8f914ff4280ccb_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-43cdd9e32d0d61174d8f914ff4280ccb_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="556" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic4.zhimg.com/v2-43cdd9e32d0d61174d8f914ff4280ccb_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-43cdd9e32d0d61174d8f914ff4280ccb_b.jpg" data-lazy-status="ok"></figure><p>接着操作系统切换到核心态，处理中断信号 </p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-f07196e25b42671a798bfeaf55bb773b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="603" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://picb.zhimg.com/v2-f07196e25b42671a798bfeaf55bb773b_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-f07196e25b42671a798bfeaf55bb773b_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="603" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://picb.zhimg.com/v2-f07196e25b42671a798bfeaf55bb773b_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-f07196e25b42671a798bfeaf55bb773b_b.jpg" data-lazy-status="ok"></figure><p><br> </p><ul><li>操作系统发现<code>中断的信号</code>是第一个程序的时间片（每个程序不能一直执行，CPU会给每个程序一定的执行时间，这段时间就是时间片）用完了，应该换第二个应用程序执行了</li><li>切换到<code>第2个进程</code>后，操作系统会将<code>CPU</code>的<code>使用权</code>交换给第二个应用程序，接着第二个应用程序就在<code>用户态</code>下开始执行。</li><li><code>进程</code>2需要调用<code>打印机资源</code>，这时会执行一个<code>系统调用</code>（后面会讲系统调用，这里简单理解为需要操作系统进入核心态处理的函数），让操作系统进入核心态，去调用打印机资源</li><li>打印机开始工作，<code>此时进程2</code>因为要等待打印机启动，操作系统就不等待了（等到打印机准备好了，再回来执行程序2），直接切换到<code>第三个应用程序</code>执行</li><li>等到打印机准备好了，此时打印机通过I/O控制器会给操作系统发出一<code>个中断信号</code>，操作系统又进入到核心态，发现这个中断是因为<code>程序2</code>等待打印机资源，现在打印机准备好了，就切换到<code>程序2</code>，切换到<code>用户态</code>，把CPU给程序2继续执行。</li></ul><p> 好了，现在可以给出一个结论，就是用户态、核心态之间的切换是怎么实现的?<br> </p><ul><li>"用户态 ---&gt; 核心态"是通过中断实现的。<code>并且中断时唯一途径</code>。</li><li>"核心态 ---&gt; 用户态"的切换时通过执行一个特权指令，将程序状态的标志位设为用户态</li></ul><p><b>2.4 中断的分类</b></p><p>举一个例子，什么是内中断和外中断：</p><p>接着说之前的范桶同学，小时候不爱学习，每次学习着学习着突然异想天开，回过神来已经过好好长一段时间，这是<code>内部中断</code>。想着想着老师走过来，给了范捅一嘴巴，这是<code>外部中断</code>。</p><p>官方解释如下： <br></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-378e8758492b0c99565f1ea068080fda_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="505" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic2.zhimg.com/v2-378e8758492b0c99565f1ea068080fda_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-378e8758492b0c99565f1ea068080fda_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="505" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic2.zhimg.com/v2-378e8758492b0c99565f1ea068080fda_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-378e8758492b0c99565f1ea068080fda_b.jpg" data-lazy-status="ok"></figure><ul><li>内中断常见的情况如<code>程序非法操作</code>(比如你要拿的的数据的内存地址不是内存地址，是系统无法识别的地址)，<code>地址越界</code>(比如系统给你的程序分配了一些内存，但是你访问的时候超出了你应该访问的内存范围)、<code>浮点溢出</code>(比如系统只能表示1.1到5.1的范围，你输入一个100, 超出了计算机能处理的范围)，或者<code>异常</code>，<code>陷入trap</code>（是指应用程序请求系统调用造成的，什么是系统调用，后面小节会举例讲）。</li><li>外中断常见的情况如<code>I/O中断</code>（由I/O控制器产生，用于发送信号通知操作完成等信号，比如进程需要请求打印机资源，打印机有一个启动准备的过程，准备好了就会给CPU一个I/O中断，告诉它已经准备好了）、<code>时钟中断</code>（由处理器内部的计时器产生，允许操作系统以一定规程执行函数，操作系统每过大约15ms会进行一次线程调度，就是利用时钟中断来实现的）。</li></ul><p><b>2.5 系统调用</b></p><p>为什么需要系统调用？</p><ul><li> 比如你的程序需要<code>读取文件信息</code>，可读取文件属于<code>读取硬盘里的数</code>据，这个操作应该时CPU在<code>内核态</code>去完成的，我们的应用程序怎么让CPU去帮助我们切换到内核态完成这个工作呢，这里就需要<code>系统调用了</code>。</li><li> 这里就引出系统调用的概念和作用。</li><li> 应用程序<code>通过系统调用请求操作系统的服务</code>。系统中的各种共享资源都由操作系统统一管理，因此在用户程序中，凡是与<code>资源有关的操作</code>（如存储分配、I/O操作、文件管理等），都<code>必须</code>通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。</li></ul><p>以下内容简单看一下即可，系统调用的分类：<br> <br></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-a92b936b9a7ed4a90d949915f381397e_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="398" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://picb.zhimg.com/v2-a92b936b9a7ed4a90d949915f381397e_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-a92b936b9a7ed4a90d949915f381397e_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="398" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://picb.zhimg.com/v2-a92b936b9a7ed4a90d949915f381397e_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-a92b936b9a7ed4a90d949915f381397e_b.jpg" data-lazy-status="ok"></figure><p>需要注意的是，<code>库函数</code>和<code>系统调用</code>容易混淆。</p><ul><li>库是可重用的模块 <code>处于用户态</code></li><li>进程通过系统调用从用户态进入<code>内核态</code>， 库函数中有很大部分是对系统调用的封装</li></ul><p>举个例子：比如<code>windows</code>和<code>linux</code>中，创建进程的系统调用方法是不一样的。 但在node中的只需要调用相同函数方法就可以创建一个进程。例如</p><div class="highlight"><pre><code class="language-js"><span class="c1">// 引入创建子进程的模块
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">childProcess</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'child_process'</span><span class="p">)</span>
<span class="c1">// 获取cpu的数量
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">cpuNum</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'os'</span><span class="p">).</span><span class="nx">cpus</span><span class="p">().</span><span class="nx">length</span>

<span class="c1">// 创建与cpu数量一样的子进程
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">cpuNum</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">childProcess</span><span class="p">.</span><span class="nx">fork</span><span class="p">(</span><span class="s1">'./worker.js'</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><p><b>2.6 进程的定义、组成、组织方式、状态与转换</b></p><p>2.6.1 为什么要引入进程的概念呢？</p><ul><li>早期的计算机只支持<code>单道程序</code>（是指所有进程一个一个排队执行，A进程执行时，CPU、内存、I/O设备全是A进程控制的，等A进程执行完了，才换B进程，然后对应的资源比如CPU、内存这些才能换B用）。 </li></ul><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-226d1652b70581a24ebe4e9a05ef2d2a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1188" data-rawheight="554" class="origin_image zh-lightbox-thumb" width="1188" data-original="https://pic3.zhimg.com/v2-226d1652b70581a24ebe4e9a05ef2d2a_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-226d1652b70581a24ebe4e9a05ef2d2a_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1188" data-rawheight="554" class="origin_image zh-lightbox-thumb lazy" width="1188" data-original="https://pic3.zhimg.com/v2-226d1652b70581a24ebe4e9a05ef2d2a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-226d1652b70581a24ebe4e9a05ef2d2a_b.jpg" data-lazy-status="ok"></figure><ul><li>现代计算机是<code>多道程序</code>执行，就是同时看起来有多个程序在一起执行，那每个程序执行都需要系统分配给它资源来执行，比如<code>CPU</code>、<code>内存</code>。</li><li>拿内存来说，操作系统要知道给A程序分配的内存有哪些，给B程序分配的内存有哪些，这些都要有小本本记录下来，这个小本本就是进程的一部分，进程的一大职责就是<code>记录目前程序运行的状态</code>。</li><li>系统为每个运行的程序配置一个数据结构，称为<code>进程控制块</code>（PCB），用来描述进程的各种信息（比如代码段放在哪）。</li></ul><p><b>2.6.2 进程的定义？</b></p><p>简要的说，进程就是具有<code>独立功能的程序</code>在数据集合上<code>运行的过程</code>。(强调动态性)</p><p><b>2.6.3 PCB有哪些组成</b></p><p>如下图，分别说明一下 <br></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-6353e6e73e82b9807c1c8cd1aa098d76_b.jpg" data-caption="" data-size="normal" data-rawwidth="1000" data-rawheight="787" class="origin_image zh-lightbox-thumb" width="1000" data-original="https://pic4.zhimg.com/v2-6353e6e73e82b9807c1c8cd1aa098d76_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-6353e6e73e82b9807c1c8cd1aa098d76_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1000" data-rawheight="787" class="origin_image zh-lightbox-thumb lazy" width="1000" data-original="https://pic4.zhimg.com/v2-6353e6e73e82b9807c1c8cd1aa098d76_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-6353e6e73e82b9807c1c8cd1aa098d76_b.jpg" data-lazy-status="ok"></figure><ul><li><code>进程标识符PID</code>相当于身份证。是在进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，<code>用于区分不同的进程</code>。</li><li>用户标识符<code>UID</code>用来表示这个进程<code>所属的用户</code>是谁。</li><li>进程当前状态和优先级下一小节会详细介绍</li><li>程序段指针是指当前进程的程序在<code>内存的什么地方</code>。</li><li>数据段指针是指当前进程的数据在<code>内存的什么地方</code>。</li><li>键盘和鼠标是指进程被<code>分配得到的I/O设备</code>。</li><li>各种寄存器值是指比如把程序计数器的值，比如有些计算的结果算到一半，进程切换时需要把这些值保存下来。</li></ul><p><b>2.6.4 进程的组织</b></p><p>在一个系统中，通常由数十、数百乃至数千个<code>PCB</code>。为了对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。这里介绍一种组织方式，类似数据结构里的链表。<br> <br></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-57b7ebf064e7590df53151f0b523f0c2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="601" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic3.zhimg.com/v2-57b7ebf064e7590df53151f0b523f0c2_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-57b7ebf064e7590df53151f0b523f0c2_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="601" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic3.zhimg.com/v2-57b7ebf064e7590df53151f0b523f0c2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-57b7ebf064e7590df53151f0b523f0c2_b.jpg" data-lazy-status="ok"></figure><p><br> <b>2.6.5 进程的状态</b></p><p><code>进程是程序的一次执行。</code>在这个执行过程中，有时进程正在<code>被CPU处理</code>，有时又需要<code>等待CPU服务</code>，可见，进程的 状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p><p>进程的三种基本状态：<br> <br></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-e65f0f2fd14744a26d1ab355d76f9b06_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="582" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic2.zhimg.com/v2-e65f0f2fd14744a26d1ab355d76f9b06_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-e65f0f2fd14744a26d1ab355d76f9b06_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="582" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic2.zhimg.com/v2-e65f0f2fd14744a26d1ab355d76f9b06_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-e65f0f2fd14744a26d1ab355d76f9b06_b.jpg" data-lazy-status="ok"></figure><p>进程的另外两种状态：<br> <br></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-fedc12e913c5d3a726e386db5836b3e0_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="173" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://picb.zhimg.com/v2-fedc12e913c5d3a726e386db5836b3e0_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-fedc12e913c5d3a726e386db5836b3e0_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="173" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://picb.zhimg.com/v2-fedc12e913c5d3a726e386db5836b3e0_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-fedc12e913c5d3a726e386db5836b3e0_b.jpg" data-lazy-status="ok"></figure><p><b>2.6.6 进程状态的转换</b></p><p>进程的状态并不是一成不变的，在一定情况下会动态转换。<br> <br></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-2d74615cfad420b3ddbc023aefa2309a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="659" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://picb.zhimg.com/v2-2d74615cfad420b3ddbc023aefa2309a_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-2d74615cfad420b3ddbc023aefa2309a_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="659" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://picb.zhimg.com/v2-2d74615cfad420b3ddbc023aefa2309a_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-2d74615cfad420b3ddbc023aefa2309a_b.jpg" data-lazy-status="ok"></figure><p>以上的这些进程状态的转换是如何实现的呢，这就要引出下一个角色了，叫`原语。</p><ul><li>原语是<code>不可被中断</code>的原子操作。我们举一个例子看看原语是怎么保证不可中断的。</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-ca54d9ef9e1d89ac2071b49869c12bab_b.jpg" data-caption="" data-size="normal" data-rawwidth="1218" data-rawheight="580" class="origin_image zh-lightbox-thumb" width="1218" data-original="https://pic1.zhimg.com/v2-ca54d9ef9e1d89ac2071b49869c12bab_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-ca54d9ef9e1d89ac2071b49869c12bab_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1218" data-rawheight="580" class="origin_image zh-lightbox-thumb lazy" width="1218" data-original="https://pic1.zhimg.com/v2-ca54d9ef9e1d89ac2071b49869c12bab_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-ca54d9ef9e1d89ac2071b49869c12bab_b.jpg" data-lazy-status="ok"></figure><p>原语采用<code>关中断指令</code>和<code>开中断指令</code>实现。</p><ul><li>首先执行关中断指令</li><li>然后外部来了中断信号，不予以处理</li><li>等到开中断指令执行后，其他中断信号才有机会处理。</li></ul><p><b>2.7 进程的通信</b></p><p>为什么需要进程间通信呢？</p><p>因为进程是<code>分配系统资源的单位</code>（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。<br> <br></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-eecdaca86fd1bc961809e3bfe1aa96f0_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="521" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic1.zhimg.com/v2-eecdaca86fd1bc961809e3bfe1aa96f0_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-eecdaca86fd1bc961809e3bfe1aa96f0_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="521" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic1.zhimg.com/v2-eecdaca86fd1bc961809e3bfe1aa96f0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-eecdaca86fd1bc961809e3bfe1aa96f0_b.jpg" data-lazy-status="ok"></figure><p><b>2.7.1 进程通信方法---共享存储</b></p><p>因为两个进程的存储空间<code>不能相互访问</code>，所以操作系统就提供的一个内存空间让彼此都能访问，这就是共享存储的原理。 <br></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-3fb36859dcddbe9fdf5804a2736177d5_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="590" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic4.zhimg.com/v2-3fb36859dcddbe9fdf5804a2736177d5_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-3fb36859dcddbe9fdf5804a2736177d5_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="590" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic4.zhimg.com/v2-3fb36859dcddbe9fdf5804a2736177d5_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-3fb36859dcddbe9fdf5804a2736177d5_b.jpg" data-lazy-status="ok"></figure><p>其中，介绍一下基于存储区的共享。</p><ul><li>在内存中画出一块<code>共享存储区</code>，数据的形式、存放位置都是由进程控制，而不是操作系统。</li></ul><p><b>2.7.2 进程通信方法---管道</b></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-b515e997f54104f37d98884864437162_b.jpg" data-caption="" data-size="normal" data-rawwidth="1144" data-rawheight="464" class="origin_image zh-lightbox-thumb" width="1144" data-original="https://picb.zhimg.com/v2-b515e997f54104f37d98884864437162_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-b515e997f54104f37d98884864437162_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1144" data-rawheight="464" class="origin_image zh-lightbox-thumb lazy" width="1144" data-original="https://picb.zhimg.com/v2-b515e997f54104f37d98884864437162_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-b515e997f54104f37d98884864437162_b.jpg" data-lazy-status="ok"></figure><ul><li>管道数据是以<code>字符流</code>（注意不是字节流）的形式写入管道，当管道写满时，写进程的<code>write()</code>系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的<code>read()</code>系统调用将被阻塞。</li><li>如果没写满就不允许读。如果都没空就不允许写。</li><li>数据一旦被读出，就从管道中被丢弃，这就意味着<code>读进程</code>最多只能有一个。</li></ul><p><b>2.7.3 进程通信方法---消息传递</b></p><p>进程间的数据交换以<code>格式化的消息</code>为单位。进程通过操作系统提供的<code>"发送消息/接收消息"</code>两个原语进行数据交换。</p><p>其中消息是什么意思呢？就好像你发QQ消息，消息头的来源是你，消息体是你发的内容。如下图：<br> <br></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-0ed1a405ab13451da4076cb743a4f5be_b.jpg" data-caption="" data-size="normal" data-rawwidth="1210" data-rawheight="376" class="origin_image zh-lightbox-thumb" width="1210" data-original="https://picb.zhimg.com/v2-0ed1a405ab13451da4076cb743a4f5be_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-0ed1a405ab13451da4076cb743a4f5be_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1210" data-rawheight="376" class="origin_image zh-lightbox-thumb lazy" width="1210" data-original="https://picb.zhimg.com/v2-0ed1a405ab13451da4076cb743a4f5be_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-0ed1a405ab13451da4076cb743a4f5be_b.jpg" data-lazy-status="ok"></figure><p>接下来我们介绍一种<code>间接通信</code>的方式（很像中介者模式或者发布订阅模式）, 如下图：中介者是信箱，进程通过它来收发消息。<br> <br></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-1540e627619e9db02d939d0c416f2b23_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="438" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic4.zhimg.com/v2-1540e627619e9db02d939d0c416f2b23_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-1540e627619e9db02d939d0c416f2b23_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="438" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic4.zhimg.com/v2-1540e627619e9db02d939d0c416f2b23_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-1540e627619e9db02d939d0c416f2b23_b.jpg" data-lazy-status="ok"></figure><p><b>2.8 线程</b><br><br>为什么要引入线程呢？</p><ul><li>比如你在玩QQ的时候，QQ是一个进程，如果QQ的进程里没有多线程并发，那么QQ进程就只能<code>同一时间做一件事情</code>（比如QQ打字聊天）</li><li>但是我们真实的场景是QQ聊天的同时，还可以发文件，还可以视频聊天，这说明如果QQ<code>没有多线程并发能力</code>，QQ能够的实用性就大大降低了。所以我们<code>需要线程</code>，也就是<code>需要进程拥有能够并发</code>多个事件的能力。</li></ul><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-9941e971732a776152abf542a264a405_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="641" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic4.zhimg.com/v2-9941e971732a776152abf542a264a405_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-9941e971732a776152abf542a264a405_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="641" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic4.zhimg.com/v2-9941e971732a776152abf542a264a405_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-9941e971732a776152abf542a264a405_b.jpg" data-lazy-status="ok"></figure><p>引入线程后带来的变化 <br></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-b7ed435aba046bed7ea68e4d7c81de1c_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="461" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic2.zhimg.com/v2-b7ed435aba046bed7ea68e4d7c81de1c_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-b7ed435aba046bed7ea68e4d7c81de1c_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="461" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic2.zhimg.com/v2-b7ed435aba046bed7ea68e4d7c81de1c_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-b7ed435aba046bed7ea68e4d7c81de1c_b.jpg" data-lazy-status="ok"></figure><p><b>3 进程的同步和互斥</b></p><p>同步。是指多个进程中发生的事件存在某种先后顺序。即某些进程的执行必须先于另一些进程。</p><p>比如说<code>进程A</code>需要从缓冲区读取<code>进程B</code>产生的信息，当缓冲区为空时，<code>进程B</code>因为读取不到信息而被阻塞。而当<code>进程A</code>产生信息放入缓冲区时，<code>进程B</code>才会被唤醒。概念如图1所示。 <br></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-17268cfbbd9d6fc7193729bf56b3c77a_b.jpg" data-caption="" data-size="normal" data-rawwidth="498" data-rawheight="291" class="origin_image zh-lightbox-thumb" width="498" data-original="https://picb.zhimg.com/v2-17268cfbbd9d6fc7193729bf56b3c77a_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-17268cfbbd9d6fc7193729bf56b3c77a_720w.jpg" data-caption="" data-size="normal" data-rawwidth="498" data-rawheight="291" class="origin_image zh-lightbox-thumb lazy" width="498" data-original="https://picb.zhimg.com/v2-17268cfbbd9d6fc7193729bf56b3c77a_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-17268cfbbd9d6fc7193729bf56b3c77a_b.jpg" data-lazy-status="ok"></figure><p>互斥。是指多个进程不允许同时使用同一资源。当某个进程使用某种资源的时候，其他进程必须等待。</p><p>比如<code>进程B</code>需要访问打印机，但此时<code>进程A</code>占有了打印机，<code>进程B</code>会被阻塞，直到<code>进程A</code>释放了打印机资源,进程B才可以继续执行。概念如图3所示。 <br></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-7f6f7e617d5dcd32b4faa9d44d48d5ae_b.jpg" data-caption="" data-size="normal" data-rawwidth="443" data-rawheight="256" class="origin_image zh-lightbox-thumb" width="443" data-original="https://pic1.zhimg.com/v2-7f6f7e617d5dcd32b4faa9d44d48d5ae_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-7f6f7e617d5dcd32b4faa9d44d48d5ae_720w.jpg" data-caption="" data-size="normal" data-rawwidth="443" data-rawheight="256" class="origin_image zh-lightbox-thumb lazy" width="443" data-original="https://pic1.zhimg.com/v2-7f6f7e617d5dcd32b4faa9d44d48d5ae_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-7f6f7e617d5dcd32b4faa9d44d48d5ae_b.jpg" data-lazy-status="ok"></figure><p><br><b> 3.1 信号量（了解概念即可）</b></p><p><code>信号量</code>主要是来解决进程的<code>同步</code>和<code>互斥</code>的，我们前端需要了解，如果涉及到同步和互斥的关系（我们编程大多数关于流程的逻辑问题，本质不就是同步和互斥吗？）</p><p>在操作系统中，常用<code>P、V信号量</code>来实现进程间的<code>同步</code>和<code>互斥</code>，我们简单了解一下一种常用的信号量，<code>记录型信号量</code>来简单了解一下信号量本质是怎样的。（c语言来表示，会有备注）</p><div class="highlight"><pre><code class="language-js"><span class="cm">/*记录型信号量的定义*/</span>
<span class="nx">typedef</span> <span class="nx">struct</span> <span class="p">{</span>
    <span class="kr">int</span> <span class="nx">value</span><span class="p">;</span> <span class="c1">// 剩余资源
</span><span class="c1"></span>    <span class="nx">Struct</span> <span class="nx">process</span> <span class="o">*</span><span class="nx">L</span> <span class="c1">// 等待队列
</span><span class="c1"></span><span class="p">}</span> <span class="nx">semaphore</span>
</code></pre></div><p>意思是信号量的结构有两部分组成，<code>一部分是剩余资源value</code>，比如目前有两台打印机空闲，那么剩余资源就是2，谁正在使用打印机，剩余资源就减1。</p><p><code>Struct process *L</code>意思是，比如2台打印机都有人在用，这时候你的要用打印机，此时会把这个打印机资源的请求放入阻塞队列，L就是阻塞队列的地址。</p><div class="highlight"><pre><code class="language-js"><span class="cm">/*P 操作，也就是记录型信号量的请求资源操作*/</span>
<span class="k">void</span> <span class="nx">wait</span> <span class="p">(</span><span class="nx">semaphore</span> <span class="nx">S</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">S</span><span class="p">.</span><span class="nx">value</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">S</span><span class="p">.</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="nx">block</span> <span class="p">(</span><span class="nx">S</span><span class="p">.</span><span class="nx">L</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>需要注意的是，如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列中。</p><div class="highlight"><pre><code class="language-js"><span class="cm">/*V 操作，也就是记录型信号量的释放资源操作*/</span>
<span class="k">void</span> <span class="nx">singal</span> <span class="p">(</span><span class="nx">semaphore</span> <span class="nx">S</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">S</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">S</span><span class="p">.</span><span class="nx">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">){</span>
        <span class="nx">wakeup</span> <span class="p">(</span><span class="nx">S</span><span class="p">.</span><span class="nx">L</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>释放资源后，若还有别的进程在等待这个资源，比如打印机资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为继续态。<br> 3.2 生产者消费者问题（了解概念即可）<br> 为什么要讲这个呢，主要是node的流的机制，本质就是生产者消费者问题，可以简单的看看这个问题如何解决。<br> <br></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-56f5dcd65a46517aa670d491e4680658_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="414" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic3.zhimg.com/v2-56f5dcd65a46517aa670d491e4680658_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-56f5dcd65a46517aa670d491e4680658_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="414" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic3.zhimg.com/v2-56f5dcd65a46517aa670d491e4680658_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-56f5dcd65a46517aa670d491e4680658_b.jpg" data-lazy-status="ok"></figure><p>如上图，<code>生产者</code>的主要作用是生成<code>一定量的数据放到缓冲区中</code>，然后<code>重复此过程</code>。与此同时，消费者也在<code>缓冲区消耗这些数据</code>。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p>这里我们需要两个同步信号量和一个互斥信号量.</p><div class="highlight"><pre><code class="language-js"><span class="c1">// 互斥信号量，实现对缓冲区的互斥访问
</span><span class="c1"></span><span class="nx">semaphore</span> <span class="nx">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// 同步信号量，表示目前还可以生产几个产品
</span><span class="c1"></span><span class="nx">semaphore</span> <span class="nx">empty</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
<span class="c1">// 同步信号量，表示目前可以消耗几个产品
</span><span class="c1"></span><span class="nx">semaphore</span> <span class="nx">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div><p>生产者代码如下</p><div class="highlight"><pre><code class="language-js"><span class="nx">producer</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 生产一个产品
</span><span class="c1"></span>        <span class="nx">P</span><span class="p">(</span><span class="nx">empty</span><span class="p">);</span>
        <span class="c1">// 对缓冲区加锁
</span><span class="c1"></span>        <span class="nx">P</span><span class="p">(</span><span class="nx">mutex</span><span class="p">);</span>
        <span class="nx">这里的代码是生产一个产品</span>
        <span class="c1">// 解锁
</span><span class="c1"></span>        <span class="nx">V</span><span class="p">(</span><span class="nx">mutex</span><span class="p">);</span>
        <span class="c1">// 产出一个产品
</span><span class="c1"></span>        <span class="nx">V</span><span class="p">(</span><span class="nx">full</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>消费者代码如下</p><div class="highlight"><pre><code class="language-js"><span class="nx">producer</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 消费一个产品
</span><span class="c1"></span>        <span class="nx">P</span><span class="p">(</span><span class="nx">full</span><span class="p">);</span>
        <span class="c1">// 对缓冲区加锁
</span><span class="c1"></span>        <span class="nx">P</span><span class="p">(</span><span class="nx">mutex</span><span class="p">);</span>
        <span class="nx">这里的代码是消费一个产品</span>
        <span class="c1">// 解锁
</span><span class="c1"></span>        <span class="nx">V</span><span class="p">(</span><span class="nx">mutex</span><span class="p">);</span>
        <span class="c1">// 消费一个产品
</span><span class="c1"></span>        <span class="nx">V</span><span class="p">(</span><span class="nx">empty</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><b>4 内存的基础知识和概念</b></p><p>为什么需要内存?</p><p>内存是计算机<code>其它硬件设备</code>与``CPU沟通`的桥梁、中转站。程序执行前需要先放到内存中才能被CPU处理。</p><p><b>4.1 cpu如何区分执行程序的数据在内存的什么地方</b></p><ul><li>是通过给<code>内存的存储单元编址</code>实现的。（存储单元一般是以字节为单位）</li><li>如下图，内存的存储单元，就像一个酒店的房间，都有编号，比如程序一的数据都在1楼，1楼1号存储着程序里<code>let a = 1</code>这段代码。</li></ul><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-81676288cdcb44e93ff2fe84f90153e7_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="562" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic1.zhimg.com/v2-81676288cdcb44e93ff2fe84f90153e7_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-81676288cdcb44e93ff2fe84f90153e7_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="562" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic1.zhimg.com/v2-81676288cdcb44e93ff2fe84f90153e7_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-81676288cdcb44e93ff2fe84f90153e7_b.jpg" data-lazy-status="ok"></figure><p><b>4.2 内存管理-内存空间的分配与回收</b></p><ul><li> 内存分配分为<code>连续分配</code>和<code>非连续分配</code>，连续分配是指用户进程分配的必须是<code>一个连续的内存空间</code>。</li><li> 这里我们只讲连续分配中的<code>动态分区分配</code>。</li><li> 什么是动态分区分配呢，这种分配方式<code>不会预先划分内存分区</code>，而是在进程装入内存时，根据进程的大小<code>动态地</code>建立分区，并使分区的大小<code>正好适合</code>进程的需要。（比如，某计算机内存大小64MB，系统区8MB，用户区56MB...，现在我们有几个进程要装入内存，如下图）</li></ul><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-a36af6e683487ea844ef9775b4d46d37_b.jpg" data-caption="" data-size="normal" data-rawwidth="987" data-rawheight="606" class="origin_image zh-lightbox-thumb" width="987" data-original="https://pic4.zhimg.com/v2-a36af6e683487ea844ef9775b4d46d37_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-a36af6e683487ea844ef9775b4d46d37_720w.jpg" data-caption="" data-size="normal" data-rawwidth="987" data-rawheight="606" class="origin_image zh-lightbox-thumb lazy" width="987" data-original="https://pic4.zhimg.com/v2-a36af6e683487ea844ef9775b4d46d37_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-a36af6e683487ea844ef9775b4d46d37_b.jpg" data-lazy-status="ok"></figure><ul><li>随之而来的问题就是，如果此时进程1使用完了，相应在内存上的数据也被删除了，那么<code>空闲的区域</code>，后面该怎么分配（也就是说随着进程退出，会有很多空闲的内存区域出现）</li></ul><p>我们讲一种较为简单的处理方法叫<code>空闲分区表</code>法来解决这个问题。如下图，右侧的表格就是一个空闲分区表。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-6e75f190869be3631173ccc30f3ba25d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1029" data-rawheight="457" class="origin_image zh-lightbox-thumb" width="1029" data-original="https://pic2.zhimg.com/v2-6e75f190869be3631173ccc30f3ba25d_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-6e75f190869be3631173ccc30f3ba25d_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1029" data-rawheight="457" class="origin_image zh-lightbox-thumb lazy" width="1029" data-original="https://pic2.zhimg.com/v2-6e75f190869be3631173ccc30f3ba25d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-6e75f190869be3631173ccc30f3ba25d_b.jpg" data-lazy-status="ok"></figure><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配呢，例如下图，分别有<code>20MB</code>，<code>10MB</code>，<code>4MB</code>三个空闲分区块，现在<code>进程5</code>需要<code>4MB</code>空闲分区，改怎么分配呢？<br> 我们需要按照一定的动态分区分配算法，比如有<code>首次适应算法</code>，指的是每次都从低地址开始查找，找到第一个能满足大小的空闲分区。还有比如<code>最佳适应算法</code>，指的是从空闲分区表中找到最小的适合分配的分区块来满足需求。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-3d377f34b6249c48213b1298d403cfdc_b.jpg" data-caption="" data-size="normal" data-rawwidth="1050" data-rawheight="960" class="origin_image zh-lightbox-thumb" width="1050" data-original="https://pic1.zhimg.com/v2-3d377f34b6249c48213b1298d403cfdc_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-3d377f34b6249c48213b1298d403cfdc_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1050" data-rawheight="960" class="origin_image zh-lightbox-thumb lazy" width="1050" data-original="https://pic1.zhimg.com/v2-3d377f34b6249c48213b1298d403cfdc_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-3d377f34b6249c48213b1298d403cfdc_b.jpg" data-lazy-status="ok"></figure><p><code>连续分配缺点很明显</code>，大多数情况，需要分配的进程大小，不能跟空闲分区剩下的大小完全一样，这样就产生很多很难利用的<code>内存碎片</code>。<br> 这里我们介绍一种更好的空闲分区的分配方法，<code>基本分页存储</code>。如下图</p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-40344f5f6e75383ad2f4c21725784d4f_b.jpg" data-caption="" data-size="normal" data-rawwidth="960" data-rawheight="1130" class="origin_image zh-lightbox-thumb" width="960" data-original="https://picb.zhimg.com/v2-40344f5f6e75383ad2f4c21725784d4f_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-40344f5f6e75383ad2f4c21725784d4f_720w.jpg" data-caption="" data-size="normal" data-rawwidth="960" data-rawheight="1130" class="origin_image zh-lightbox-thumb lazy" width="960" data-original="https://picb.zhimg.com/v2-40344f5f6e75383ad2f4c21725784d4f_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-40344f5f6e75383ad2f4c21725784d4f_b.jpg" data-lazy-status="ok"></figure><p>将内存空间分为<code>一个个大小相等</code>的分区（比如：每个分区<code>4KB</code>）.每个分区就是一个<code>“页框”</code>。页框号从<code>0</code>开始。</p><p>将用户进程的地址空间分为与页框大小相等的一个个区域，称为<code>“页”</code>。每个页也是从<code>0</code>开始。</p><p>进程的页与内存的页框有着一一对应的关系。各个页不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。<br><br><b>5 文件管理</b></p><p>文件是什么？</p><p>文件就是一组有意义的<code>信息/数据</code>集合。</p><p>计算机中存放了各种各样的文件，一个文件有哪些属性呢？文件内部的数据应该怎样组织起来？文件之间又该怎么组织起来？</p><p><b>5.1 文件的属性</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-b39d13c1a192136c1ac54a5c1d71052c_b.jpg" data-caption="" data-size="normal" data-rawwidth="1077" data-rawheight="960" class="origin_image zh-lightbox-thumb" width="1077" data-original="https://pic1.zhimg.com/v2-b39d13c1a192136c1ac54a5c1d71052c_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-b39d13c1a192136c1ac54a5c1d71052c_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1077" data-rawheight="960" class="origin_image zh-lightbox-thumb lazy" width="1077" data-original="https://pic1.zhimg.com/v2-b39d13c1a192136c1ac54a5c1d71052c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-b39d13c1a192136c1ac54a5c1d71052c_b.jpg" data-lazy-status="ok"></figure><ul><li>文件名。即文件的名字，需要注意的是，同一目录下<code>不允许</code>有重名的文件。</li><li>标识符。操作系统用于区分各个文件的一种<code>内部的名称</code>。</li><li>类型。文件的类型。</li><li>位置。文件<code>存放的路径</code>，同时也是在硬盘里的位置（需要转换成物理硬盘上的地址）</li><li>创建时间、上次修改时间、文件所有者就是字面意思。</li><li>保护信息。比如对这个文件的<code>执行权限</code>，是否有删除文件权限，修改文件权限等等。</li></ul><p><b> 5.2 文件内部数据如何组织在一起</b></p><p>如下图，文件主要分为<code>有结构文件</code>和<code>无结构文件</code>。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-425ad94c14b2bb1b25219adfe6975199_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="603" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic2.zhimg.com/v2-425ad94c14b2bb1b25219adfe6975199_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-425ad94c14b2bb1b25219adfe6975199_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="603" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic2.zhimg.com/v2-425ad94c14b2bb1b25219adfe6975199_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-425ad94c14b2bb1b25219adfe6975199_b.jpg" data-lazy-status="ok"></figure><p><b>5.3 文件之间如何组织起来</b></p><p>通过<code>树状结构</code>组织的。例如<code>windows</code>的文件间的组织关系如下：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-814cf4f109a766b24aa211becd8f5083_b.jpg" data-caption="" data-size="normal" data-rawwidth="1170" data-rawheight="266" class="origin_image zh-lightbox-thumb" width="1170" data-original="https://pic2.zhimg.com/v2-814cf4f109a766b24aa211becd8f5083_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-814cf4f109a766b24aa211becd8f5083_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1170" data-rawheight="266" class="origin_image zh-lightbox-thumb lazy" width="1170" data-original="https://pic2.zhimg.com/v2-814cf4f109a766b24aa211becd8f5083_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-814cf4f109a766b24aa211becd8f5083_b.jpg" data-lazy-status="ok"></figure><p>接下来我们详细的了解一下<code>文件的逻辑结构</code></p><p><b>5.4 文件的逻辑结构</b></p><p>逻辑结构是指，在用户看来，文件内部的数据是如何组织起来的，而<code>“物理结构”</code>是在操作系统看来，文件是如何保存在外存，比如<code>硬盘</code>中的。</p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-16ca235ec9dd3adb9627ffb5e1aa756b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1061" data-rawheight="302" class="origin_image zh-lightbox-thumb" width="1061" data-original="https://picb.zhimg.com/v2-16ca235ec9dd3adb9627ffb5e1aa756b_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-16ca235ec9dd3adb9627ffb5e1aa756b_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1061" data-rawheight="302" class="origin_image zh-lightbox-thumb lazy" width="1061" data-original="https://picb.zhimg.com/v2-16ca235ec9dd3adb9627ffb5e1aa756b_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-16ca235ec9dd3adb9627ffb5e1aa756b_b.jpg" data-lazy-status="ok"></figure><p>比如，<code>“线性表”</code>就是一种逻辑结构，在用户看来，线性表就是一组有先后关系的元素序列，如：<code>a,b,c,d,e....</code> </p><ul><li><code>“线性表”</code>这种逻辑结构可以用不同的物理结构实现，比如：<code>顺序表/链表</code>。<code>顺序表</code>的各个元素在逻辑上相邻，在物理上也相邻：而<code>链表</code>的各个元素在物理上可以是不相邻的。</li><li>因此，顺序表可以实现<code>“随机访问”</code>，而<code>“链表”</code>无法实现随机访问。</li></ul><p>接下来我了解一下有结构文件的三种逻辑结构</p><p><b>5.4.1 顺序文件</b></p><p>什么是顺序文件</p><p>指的是文件中的记录一个接一个地在逻辑上是<code>顺序排列</code>，记录可以是<code>定长</code>或<code>变长</code>，各个记录在物理上可以<code>顺序存储</code>或<code>链式存储</code><br> <br></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-0bae88a10cdc1cae786fc8058e5f6857_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="173" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic2.zhimg.com/v2-0bae88a10cdc1cae786fc8058e5f6857_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-0bae88a10cdc1cae786fc8058e5f6857_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="173" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic2.zhimg.com/v2-0bae88a10cdc1cae786fc8058e5f6857_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-0bae88a10cdc1cae786fc8058e5f6857_b.jpg" data-lazy-status="ok"></figure><p><br> </p><ul><li>顺序文件按结构来划分，可以分为<code>串结构</code>和<code>顺序结构</code>。</li><li>串结构是指记录之间的顺序与<code>关键字无关</code>，通常都是按照记录的时间决定记录的顺序。</li><li>顺序结构就必须保证记录之间的先后顺序按<code>关键字排列</code>。</li></ul><p>这里需要注意的知识点是，顺序文件的存储方式和是否<code>按关键字排列</code>，会影响数据<code>是否支持随机存取</code>和<code>是否可以快速按关键字找到对应记录</code>的功能。<br> <br></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-0c48cacc53fe65a4cdd9f89d6b7c738c_b.jpg" data-caption="" data-size="normal" data-rawwidth="985" data-rawheight="216" class="origin_image zh-lightbox-thumb" width="985" data-original="https://pic3.zhimg.com/v2-0c48cacc53fe65a4cdd9f89d6b7c738c_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-0c48cacc53fe65a4cdd9f89d6b7c738c_720w.jpg" data-caption="" data-size="normal" data-rawwidth="985" data-rawheight="216" class="origin_image zh-lightbox-thumb lazy" width="985" data-original="https://pic3.zhimg.com/v2-0c48cacc53fe65a4cdd9f89d6b7c738c_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-0c48cacc53fe65a4cdd9f89d6b7c738c_b.jpg" data-lazy-status="ok"></figure><p><b>5.4.2 索引文件</b></p><p>对于<code>可变长记录文件</code>，要找到<code>第i</code>个记录，必须先顺序查找<code>前i-1</code>个记录，但是很多场景中又必须使用可变长记录，如何解决这个问题呢？这就引出来马上讲的<code>索引文件</code><br> <br></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-fdc7568d2a42acfe295964805fa2b0bb_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="482" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic1.zhimg.com/v2-fdc7568d2a42acfe295964805fa2b0bb_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-fdc7568d2a42acfe295964805fa2b0bb_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="482" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic1.zhimg.com/v2-fdc7568d2a42acfe295964805fa2b0bb_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-fdc7568d2a42acfe295964805fa2b0bb_b.jpg" data-lazy-status="ok"></figure><ul><li> 给这些变长的记录都用一张索引表来记录，一个索引表项包括了<code>索引号</code>，<code>长度</code>和<code>指针</code>。</li><li> 其中，可以将关键字作为索引号的内容，如果关键字本身的排列是有序的，那么还可以按照关键字进行折半查找。</li><li> 但是建立索引表的问题也很明显，首先若要<code>删除/增加</code>一个记录，同时也要对<code>索引表</code>操作，其次，如果<code>增加一条记录才1KB</code>，但是索引表<code>增加i一条记录可能有8KB</code>，以至于索引表的体积大大多于记录。存储空间的利用率就比较低。</li></ul><p><b>5.4.3 索引顺序文件</b></p><p>索引顺序文件是<code>索引文件</code>和<code>顺序文件</code>思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是，并不是每个记录对应一个<code>索引表项</code>，而是一组记录对应一个索引表项。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-cced46e64a63f8174180146ba93b2aca_b.jpg" data-caption="" data-size="normal" data-rawwidth="894" data-rawheight="671" class="origin_image zh-lightbox-thumb" width="894" data-original="https://pic1.zhimg.com/v2-cced46e64a63f8174180146ba93b2aca_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-cced46e64a63f8174180146ba93b2aca_720w.jpg" data-caption="" data-size="normal" data-rawwidth="894" data-rawheight="671" class="origin_image zh-lightbox-thumb lazy" width="894" data-original="https://pic1.zhimg.com/v2-cced46e64a63f8174180146ba93b2aca_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-cced46e64a63f8174180146ba93b2aca_b.jpg" data-lazy-status="ok"></figure><p><b>5.5 文件目录</b></p><p>首先，我们需要了解一下<code>文件控制</code>块是什么。我们假设目前在<code>windows的D盘</code>，如下图</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-4e2e285870f324afa71fcda924a90298_b.jpg" data-caption="" data-size="normal" data-rawwidth="952" data-rawheight="349" class="origin_image zh-lightbox-thumb" width="952" data-original="https://pic4.zhimg.com/v2-4e2e285870f324afa71fcda924a90298_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-4e2e285870f324afa71fcda924a90298_720w.jpg" data-caption="" data-size="normal" data-rawwidth="952" data-rawheight="349" class="origin_image zh-lightbox-thumb lazy" width="952" data-original="https://pic4.zhimg.com/v2-4e2e285870f324afa71fcda924a90298_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-4e2e285870f324afa71fcda924a90298_b.jpg" data-lazy-status="ok"></figure><p>可以看到，目录本身就是一种<code>有结构的文件</code>，记录了目录里的<code>文件</code>和<code>目录</code>的信息，比如名称和类型。而这些一条条的记录就是一个个的<code>“文件控制块”（FCB）</code>。</p><p>文件目录的结构通常是<code>树状的</code>，例如linux里<code>/</code>是指根路径，<code>/home</code>是根路径下的二级目录<br></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-61c6d26f7ab9aa935ea434968a97d2d9_b.jpg" data-caption="" data-size="normal" data-rawwidth="462" data-rawheight="140" class="origin_image zh-lightbox-thumb" width="462" data-original="https://picb.zhimg.com/v2-61c6d26f7ab9aa935ea434968a97d2d9_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-61c6d26f7ab9aa935ea434968a97d2d9_720w.jpg" data-caption="" data-size="normal" data-rawwidth="462" data-rawheight="140" class="origin_image zh-lightbox-thumb lazy" width="462" data-original="https://picb.zhimg.com/v2-61c6d26f7ab9aa935ea434968a97d2d9_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-61c6d26f7ab9aa935ea434968a97d2d9_b.jpg" data-lazy-status="ok"></figure><ul><li>需要注意的是，树状目录<code>不容易实现文件共享</code>，所以在树形目录结构的基础上，增加了一些指向同一节点的有向边（可以简单理解为引用关系，就跟js里的对象一样）</li><li>也就是说需要为<code>每个共享节点</code>设置一个<code>共享计数器</code>，用于记录此时有多少个地方在共享该结点。只有<code>共享计数器减为0</code>，才删除该节点。</li></ul><p><b>5.6 文件存储空间管理</b></p><p>首先，我们了解一下磁盘分为<code>目录区</code>和<code>文件区</code>。</p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-eef6e13eb0594957619479b01c0f019e_b.jpg" data-caption="" data-size="normal" data-rawwidth="713" data-rawheight="545" class="origin_image zh-lightbox-thumb" width="713" data-original="https://picb.zhimg.com/v2-eef6e13eb0594957619479b01c0f019e_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-eef6e13eb0594957619479b01c0f019e_720w.jpg" data-caption="" data-size="normal" data-rawwidth="713" data-rawheight="545" class="origin_image zh-lightbox-thumb lazy" width="713" data-original="https://picb.zhimg.com/v2-eef6e13eb0594957619479b01c0f019e_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-eef6e13eb0594957619479b01c0f019e_b.jpg" data-lazy-status="ok"></figure><p>接着，我们了解一下常见的两种<code>文件存储空间的管理算法</code>，如下图，假如硬盘上<code>空闲的数据块</code>是蓝色，<code>非空闲的数据</code>块是橙色。</p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-184c51214e242b01930a749d58d242f6_b.jpg" data-caption="" data-size="normal" data-rawwidth="367" data-rawheight="460" class="content_image" width="367"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-184c51214e242b01930a749d58d242f6_720w.jpg" data-caption="" data-size="normal" data-rawwidth="367" data-rawheight="460" class="content_image lazy" width="367" data-actualsrc="https://picb.zhimg.com/v2-184c51214e242b01930a749d58d242f6_b.jpg" data-lazy-status="ok"></figure><p>对分配连续的存储空间，可以采用<code>空闲表法</code>（只讲这种较简单的方法）来<code>分配</code>和<code>回收</code>磁盘块。对于分配，可以采用首次适应，最佳适应等算法来决定要为文件分配哪个区间。（空闲表表示如下）</p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-552726db497f3a256d5b8eb92779c724_b.jpg" data-caption="" data-size="normal" data-rawwidth="799" data-rawheight="473" class="origin_image zh-lightbox-thumb" width="799" data-original="https://picb.zhimg.com/v2-552726db497f3a256d5b8eb92779c724_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-552726db497f3a256d5b8eb92779c724_720w.jpg" data-caption="" data-size="normal" data-rawwidth="799" data-rawheight="473" class="origin_image zh-lightbox-thumb lazy" width="799" data-original="https://picb.zhimg.com/v2-552726db497f3a256d5b8eb92779c724_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-552726db497f3a256d5b8eb92779c724_b.jpg" data-lazy-status="ok"></figure><ul><li><code>首次适应</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>第一个满足条件</code>的空闲区间。</li><li><code>最佳适应算法</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>满足条件而且空闲块最小的空闲区间</code>。</li></ul><p>如何回收磁盘块呢，主要分为以下4中情况</p><ul><li>回收区的前后没有相邻空闲区</li><li>回收区前后都是空闲区</li><li>回收区前面是空前去</li><li>回收区后面是空闲区</li></ul><p>最重要的是要注意表项合并的问题。(比如说回收区前后都有空闲区就将其一起合并为一个空闲区.</p><p><b>5.7 文件共享</b></p><p>文件共享分为两种<br> <br></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-b5c21b67b3598f93f8f32b6897a57740_b.jpg" data-caption="" data-size="normal" data-rawwidth="981" data-rawheight="153" class="origin_image zh-lightbox-thumb" width="981" data-original="https://pic4.zhimg.com/v2-b5c21b67b3598f93f8f32b6897a57740_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-b5c21b67b3598f93f8f32b6897a57740_720w.jpg" data-caption="" data-size="normal" data-rawwidth="981" data-rawheight="153" class="origin_image zh-lightbox-thumb lazy" width="981" data-original="https://pic4.zhimg.com/v2-b5c21b67b3598f93f8f32b6897a57740_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-b5c21b67b3598f93f8f32b6897a57740_b.jpg" data-lazy-status="ok"></figure><ul><li> 注意，多个用户<code>共享同一个文件</code>，意味着系统只有<code>“一份”</code>文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到<code>文件的变化</code>。</li><li> 软连接可以理解为<code>windows</code>里的<code>快捷方式</code>。</li><li> 硬链接可以理解为js里的<code>引用计数</code>，只有引用为<code>0</code>的时候，才会真正删除这个文件。</li></ul><p><b>5.8 文件保护</b></p><p>操作系统需要保护文件的安全，一般有如下3种方式：</p><ul><li>口令保护。是指为文件设置一个<code>“口令”</code>（比如123），用户请求访问该文件时必须提供对应的口令。口令一般放在文件对应的<code>FCB或者索引结点</code>上。</li><li>加密保护。使用某个<code>"密码"</code>对文件进行加密，在访问文件时需要提供<code>正确的“密码”</code>才能对文件进行正确的解密。</li><li>访问控制。在每个文件的FCB或者索引节点种增加一个<code>访问控制列表</code>，该表中记录了各个用户可以对该文件执行哪些操作。</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-a7b61237f5eba1205a19290a08c6784a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="401" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic1.zhimg.com/v2-a7b61237f5eba1205a19290a08c6784a_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-a7b61237f5eba1205a19290a08c6784a_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="401" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic1.zhimg.com/v2-a7b61237f5eba1205a19290a08c6784a_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-a7b61237f5eba1205a19290a08c6784a_b.jpg" data-lazy-status="ok"></figure><p><b>6 I/O设备</b></p><p>什么是I/O设备</p><p>I/O就是<code>输入输出</code>(Input/Output)的意思，I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。 <br></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-26188020b9338b10a756b3dae6544a7f_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="492" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic1.zhimg.com/v2-26188020b9338b10a756b3dae6544a7f_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-26188020b9338b10a756b3dae6544a7f_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="492" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic1.zhimg.com/v2-26188020b9338b10a756b3dae6544a7f_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-26188020b9338b10a756b3dae6544a7f_b.jpg" data-lazy-status="ok"></figure><p><b>6.1 I/O设备分类--按使用特性</b></p><ul><li>人机交互类设备，这类设备传输数据的速度慢</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-cc38dc414319ff5bb2650652ee72e94f_b.jpg" data-caption="" data-size="normal" data-rawwidth="679" data-rawheight="632" class="origin_image zh-lightbox-thumb" width="679" data-original="https://picb.zhimg.com/v2-cc38dc414319ff5bb2650652ee72e94f_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-cc38dc414319ff5bb2650652ee72e94f_720w.jpg" data-caption="" data-size="normal" data-rawwidth="679" data-rawheight="632" class="origin_image zh-lightbox-thumb lazy" width="679" data-original="https://picb.zhimg.com/v2-cc38dc414319ff5bb2650652ee72e94f_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-cc38dc414319ff5bb2650652ee72e94f_b.jpg" data-lazy-status="ok"></figure><ul><li>存储设备，这类设备传输数据的速度较快</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-14521ea1707fe79e07d26cdbcea1bfdc_b.jpg" data-caption="" data-size="normal" data-rawwidth="573" data-rawheight="561" class="origin_image zh-lightbox-thumb" width="573" data-original="https://pic3.zhimg.com/v2-14521ea1707fe79e07d26cdbcea1bfdc_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-14521ea1707fe79e07d26cdbcea1bfdc_720w.jpg" data-caption="" data-size="normal" data-rawwidth="573" data-rawheight="561" class="origin_image zh-lightbox-thumb lazy" width="573" data-original="https://pic3.zhimg.com/v2-14521ea1707fe79e07d26cdbcea1bfdc_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-14521ea1707fe79e07d26cdbcea1bfdc_b.jpg" data-lazy-status="ok"></figure><ul><li>网络通信设备，这类设备的传输速度介于人机交互设备和存储设备之间</li></ul><p><b>6.2 I/O控制器</b></p><p>CPU无法直接控制<code>I/O设备的机械部件</code>，因此I/O设备还要有一个电子部件作为<code>CPU</code>和<code>I/O设备</code>机械部件之间的<code>“中介”</code>，用于实现CPU对设备的控制。这个电子部件就是<code>I/O控制器</code>。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-1cdd195e726a3ba08f48454d2aac78f9_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="350" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://pic2.zhimg.com/v2-1cdd195e726a3ba08f48454d2aac78f9_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-1cdd195e726a3ba08f48454d2aac78f9_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="350" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://pic2.zhimg.com/v2-1cdd195e726a3ba08f48454d2aac78f9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-1cdd195e726a3ba08f48454d2aac78f9_b.jpg" data-lazy-status="ok"></figure><ul><li>接收和识别CPU发出的指令是指，比如CPU发来读取文件的命令，I/O控制器中会有相应的<code>控制寄存器</code>来存放命令和参数</li><li>向cpu报告设备的状态是指，I/O控制器会有相应的<code>状态寄存器</code>，用来记录I/O设备<code>是否空闲</code>或者<code>忙碌</code></li><li>数据交换是指I/O控制器会设置相应的<code>数据寄存器</code>。输出时，数据寄存器用于<code>暂存CPU发来的数据</code>，之后再由控制器传送给设备。</li><li>地址识别是指，为了区分设备控制器中的各个寄存器中的各个寄存器，也需要给各个寄存器设置一个特性的<code>“地址”</code>。I/O控制器通过CPU提供的“地址”来判断CPU要读写的是哪个寄存器</li></ul><p><b>6.3 I/O控制方式</b></p><ul><li> 这里我们指讲一下目前比较先进的方式，通道控制方式。<br> </li><li> 通道可以理解为一种<code>“弱鸡版CPU”</code>。通道可以识别并执行一系列通道指令。 <br></li></ul><figure data-size="normal"><noscript><img src="https://picb.zhimg.com/v2-93df69aabbeddf94abf5784b5075de93_b.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="563" class="origin_image zh-lightbox-thumb" width="1280" data-original="https://picb.zhimg.com/v2-93df69aabbeddf94abf5784b5075de93_r.jpg"/></noscript><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-93df69aabbeddf94abf5784b5075de93_720w.jpg" data-caption="" data-size="normal" data-rawwidth="1280" data-rawheight="563" class="origin_image zh-lightbox-thumb lazy" width="1280" data-original="https://picb.zhimg.com/v2-93df69aabbeddf94abf5784b5075de93_r.jpg" data-actualsrc="https://picb.zhimg.com/v2-93df69aabbeddf94abf5784b5075de93_b.jpg" data-lazy-status="ok"></figure><p>通道最大的优点是极大的<code>减少了CPU的干预频率</code>，<code>I/O设备</code>完成任务，通道会向CPU发出<code>中断</code>，不需要轮询来问I/O设备是否完成CPU下达的任务。</p><p>本文完结。</p><p>预告：后面会有数据结构入门知识（常用的数据结构以及在内存的存储形式，并对比其增删改查的时间复杂度）</p><p>注： 本文绝大多数资料来源于以下的学习视频资料<br> </p><ul><li><a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av6538245%3Ffrom%3Dsearch%26seid%3D6918809747167691096" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">操作系统_清华大学（陈渝）</a></li><li><a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av70156862%3Ffrom%3Dsearch%26seid%3D6918809747167691096" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">2019 王道考研 操作系统</a></li><li><a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av51437944%3Ffrom%3Dsearch%26seid%3D6918809747167691096" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">操作系统（哈工大李治军老师）32讲</a></li></ul><blockquote>作者：lio-mengxiang<br>链接：<a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5e52924e51882549274a51e3" class=" external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043"><span class="invisible">https://</span><span class="visible">juejin.im/post/5e52924e</span><span class="invisible">51882549274a51e3</span><span class="ellipsis"></span></a><br>来源：掘金</blockquote></div></div><div class="ContentItem-time">发布于 04-15</div><div class="Post-topicsAndReviewer"><div class="TopicList Post-Topics"><div class="Tag Topic" data-za-detail-view-path-module="TopicItem" data-za-extra-module="{&quot;card&quot;:{&quot;content&quot;:{&quot;type&quot;:&quot;Topic&quot;,&quot;token&quot;:&quot;19590813&quot;}}}"><span class="Tag-content"><a class="TopicLink" href="https://www.zhihu.com/topic/19590813" target="_blank"><div class="Popover"><div id="Popover2-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover2-content">前端入门</div></div></a></span></div><div class="Tag Topic" data-za-detail-view-path-module="TopicItem" data-za-extra-module="{&quot;card&quot;:{&quot;content&quot;:{&quot;type&quot;:&quot;Topic&quot;,&quot;token&quot;:&quot;19552330&quot;}}}"><span class="Tag-content"><a class="TopicLink" href="https://www.zhihu.com/topic/19552330" target="_blank"><div class="Popover"><div id="Popover3-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover3-content">程序员</div></div></a></span></div><div class="Tag Topic" data-za-detail-view-path-module="TopicItem" data-za-extra-module="{&quot;card&quot;:{&quot;content&quot;:{&quot;type&quot;:&quot;Topic&quot;,&quot;token&quot;:&quot;19550901&quot;}}}"><span class="Tag-content"><a class="TopicLink" href="https://www.zhihu.com/topic/19550901" target="_blank"><div class="Popover"><div id="Popover4-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover4-content">前端开发</div></div></a></span></div></div></div><div><div class="Sticky RichContent-actions is-fixed is-bottom" style="width: 690px; bottom: 0px; left: 414.6px;"><div class="ContentItem-actions" data-za-detail-view-path-module="BottomBar" data-za-extra-module="{&quot;card&quot;:{&quot;content&quot;:{&quot;type&quot;:&quot;Post&quot;,&quot;id&quot;:&quot;130905785&quot;}}}"><span><button aria-label="赞同 2 " type="button" class="Button VoteButton VoteButton--up"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--TriangleUp VoteButton-TriangleUp" fill="currentColor" viewBox="0 0 24 24" width="10" height="10"><path d="M2 18.242c0-.326.088-.532.237-.896l7.98-13.203C10.572 3.57 11.086 3 12 3c.915 0 1.429.571 1.784 1.143l7.98 13.203c.15.364.236.57.236.896 0 1.386-.875 1.9-1.955 1.9H3.955c-1.08 0-1.955-.517-1.955-1.9z" fill-rule="evenodd"></path></svg></span>赞同 2</button><button aria-label="反对" type="button" class="Button VoteButton VoteButton--down"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--TriangleDown" fill="currentColor" viewBox="0 0 24 24" width="10" height="10"><path d="M20.044 3H3.956C2.876 3 2 3.517 2 4.9c0 .326.087.533.236.896L10.216 19c.355.571.87 1.143 1.784 1.143s1.429-.572 1.784-1.143l7.98-13.204c.149-.363.236-.57.236-.896 0-1.386-.876-1.9-1.956-1.9z" fill-rule="evenodd"></path></svg></span></button></span><button type="button" class="Button BottomActions-CommentBtn Button--plain Button--withIcon Button--withLabel"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--Comment Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M10.241 19.313a.97.97 0 0 0-.77.2 7.908 7.908 0 0 1-3.772 1.482.409.409 0 0 1-.38-.637 5.825 5.825 0 0 0 1.11-2.237.605.605 0 0 0-.227-.59A7.935 7.935 0 0 1 3 11.25C3 6.7 7.03 3 12 3s9 3.7 9 8.25-4.373 9.108-10.759 8.063z" fill-rule="evenodd"></path></svg></span>添加评论</button><div class="Popover ShareMenu"><div class="ShareMenu-toggler" id="Popover5-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover5-content"><button type="button" class="Button Button--plain Button--withIcon Button--withLabel"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--Share Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M2.931 7.89c-1.067.24-1.275 1.669-.318 2.207l5.277 2.908 8.168-4.776c.25-.127.477.198.273.39L9.05 14.66l.927 5.953c.18 1.084 1.593 1.376 2.182.456l9.644-15.242c.584-.892-.212-2.029-1.234-1.796L2.93 7.89z" fill-rule="evenodd"></path></svg></span>分享</button></div></div><button type="button" class="Button ContentItem-action Button--plain Button--withIcon Button--withLabel"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--Heart Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M2 8.437C2 5.505 4.294 3.094 7.207 3 9.243 3 11.092 4.19 12 6c.823-1.758 2.649-3 4.651-3C19.545 3 22 5.507 22 8.432 22 16.24 13.842 21 12 21 10.158 21 2 16.24 2 8.437z" fill-rule="evenodd"></path></svg></span>喜欢</button><button type="button" class="Button ContentItem-action Button--plain Button--withIcon Button--withLabel"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--Star Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M5.515 19.64l.918-5.355-3.89-3.792c-.926-.902-.639-1.784.64-1.97L8.56 7.74l2.404-4.871c.572-1.16 1.5-1.16 2.072 0L15.44 7.74l5.377.782c1.28.186 1.566 1.068.64 1.97l-3.89 3.793.918 5.354c.219 1.274-.532 1.82-1.676 1.218L12 18.33l-4.808 2.528c-1.145.602-1.896.056-1.677-1.218z" fill-rule="evenodd"></path></svg></span>收藏</button><button type="button" class="Button ContentItem-action Button--plain Button--withIcon Button--withLabel"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--Deliver Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M5.171 4H18.83a1.5 1.5 0 0 1 1.455 1.136l2.597 10.386a4 4 0 0 1 .119.97V19s0 2-2.002 2H3c-2 0-2-2-2-2v-2.508a4 4 0 0 1 .12-.97L3.715 5.136A1.5 1.5 0 0 1 5.171 4zm1.074 2a1 1 0 0 0-.97.761l-2.123 8.62a.5.5 0 0 0 .486.619h4.717a1 1 0 0 1 .892.548C9.906 17.85 10.824 18.5 12 18.5c1.176 0 2.094-.65 2.753-1.952a1 1 0 0 1 .892-.548h4.717a.5.5 0 0 0 .486-.62l-2.122-8.619A1 1 0 0 0 17.755 6H6.245zM8 9c0-.552.453-1 .997-1h6.006c.55 0 .997.444.997 1 0 .552-.453 1-.997 1H8.997A.996.996 0 0 1 8 9zm-1.5 4c0-.552.445-1 .996-1h9.008c.55 0 .996.444.996 1 0 .552-.445 1-.996 1H7.496a.995.995 0 0 1-.996-1z"></path></svg></span>申请转载</button><div class="Post-ActionMenuButton"><div class="Popover"><div id="Popover6-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover6-content"><button type="button" class="Button Button--plain Button--withIcon Button--iconOnly"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--Dots Button-zi" fill="currentColor" viewBox="0 0 24 24" width="1.2em" height="1.2em"><path d="M5 14a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm7 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm7 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4z" fill-rule="evenodd"></path></svg></span></button></div></div></div></div><div class="Post-SideActions" data-za-detail-view-path-module="LeftTabBar" data-za-extra-module="{&quot;card&quot;:{&quot;content&quot;:{&quot;type&quot;:&quot;Post&quot;,&quot;id&quot;:&quot;130905785&quot;}}}" style="opacity: 1;"><button class="like"><div class="Post-SideActions-icon"><svg class="Zi Zi--TriangleUp Post-SideActions-upIcon" fill="currentColor" viewBox="0 0 24 24" width="16" height="16"><path d="M2 18.242c0-.326.088-.532.237-.896l7.98-13.203C10.572 3.57 11.086 3 12 3c.915 0 1.429.571 1.784 1.143l7.98 13.203c.15.364.236.57.236.896 0 1.386-.875 1.9-1.955 1.9H3.955c-1.08 0-1.955-.517-1.955-1.9z" fill-rule="evenodd"></path></svg></div><div class="likeCount"><div class="likeCount-inner" data-previous="已赞同 3">赞同 2</div></div></button><div class="Popover ShareMenu"><div class="ShareMenu-toggler" id="Popover15-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover15-content"><img class="ShareMenu-fakeQRCode" src="https://www.zhihu.com/qrcode?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F130905785%23showWechatShareTip" alt="微信二维码"><button><div class="Post-SideActions-icon"><span style="display: inline-flex; align-items: center;">​<svg class="Zi Zi--Share" fill="currentColor" viewBox="0 0 24 24" width="20" height="20"><path d="M2.931 7.89c-1.067.24-1.275 1.669-.318 2.207l5.277 2.908 8.168-4.776c.25-.127.477.198.273.39L9.05 14.66l.927 5.953c.18 1.084 1.593 1.376 2.182.456l9.644-15.242c.584-.892-.212-2.029-1.234-1.796L2.93 7.89z" fill-rule="evenodd"></path></svg></span></div>分享</button></div></div></div></div><div class="Sticky--holder" style="position: static; top: auto; right: auto; bottom: 0px; left: 0px; display: block; float: none; margin: 0px 0px 10px; height: 54px;"></div></div></article><div class="Post-Sub Post-NormalSub"><div class="PostIndex-Contributions" data-za-detail-view-path-module="ColumnList" data-za-detail-view-path-module_name="文章被以下专栏收录" data-za-extra-module="{}"><h3 class="BlockTitle">文章被以下专栏收录</h3><ul><div class="ContentItem Column-ColumnItem"><div class="ContentItem-main"><div class="ContentItem-image"><a class="ColumnLink" href="https://www.zhihu.com/column/c_1212785891581743104"><div class="Popover"><div id="Popover7-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover7-content"><img class="Avatar Avatar--medium Avatar--round" width="40" height="40" src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-850cfe4aadc723609aa303d5e1710859_xs.jpg" srcset="https://pic3.zhimg.com/v2-850cfe4aadc723609aa303d5e1710859_l.jpg?source=172ae18b 2x" alt="前端转行指南"></div></div></a></div><div class="ContentItem-head"><h2 class="ContentItem-title"><a class="ColumnLink ColumnItem-Title" href="https://www.zhihu.com/column/c_1212785891581743104"><div class="Popover"><div id="Popover8-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover8-content">前端转行指南</div></div></a></h2><div class="ContentItem-meta">让大家都知道前端和培训都是怎么一回事。</div></div><div class="ContentItem-extra"><button type="button" class="Button FollowButton Button--primary Button--blue">关注专栏</button></div></div></div></ul></div><div class="Recommendations-Main" style="width: 1519px;"><h3 class="BlockTitle Recommendations-BlockTitle">推荐阅读</h3><ul class="Recommendations-List"><button class="PagingButton PagingButton-Previous" disabled="" data-za-detail-view-path-module="Unknown" data-za-detail-view-path-module_name="推荐阅读" data-za-extra-module="{}"><svg class="Zi Zi--ArrowLeft" fill="#d3d3d3" viewBox="0 0 24 24" width="40" height="40"><path d="M14.782 16.78a.737.737 0 0 1-1.052 0L9.218 12.53a.758.758 0 0 1 0-1.063L13.73 7.22a.737.737 0 0 1 1.052 0c.29.294.29.77.001 1.063L11 12l3.782 3.716c.29.294.29.77 0 1.063z" fill-rule="evenodd"></path></svg></button><a href="https://zhuanlan.zhihu.com/p/154036965" class="PostItem"><div><img src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/v2-9b03d79dc43fc4152f969e234909425c_250x0.jpg" srcset="https://pic3.zhimg.com/v2-9b03d79dc43fc4152f969e234909425c_qhd.jpg?source=172ae18b 2x" class="PostItem-TitleImage" alt="前端职业规划 - 写给年轻的前端韭菜们"><h1 class="PostItem-Title">前端职业规划 - 写给年轻的前端韭菜们</h1><div class="PostItem-Footer"><span>晴空万里g...</span><span class="PostItem-FooterTitle">发表于零基础学习...</span></div></div></a><a href="https://zhuanlan.zhihu.com/p/58012426" class="PostItem"><div><h1 class="PostItem-Title">前端的你，不要看什么书，不要做什么事！</h1><p class="PostItem-Summary">很多前端都想找一个学习计划，然后认真学，成为一个大牛；他们迫切的想知道自己该学什么，然后看什么书，有什么资源可以用！我今天要告诉你的是，你不要看什么书，不要做什么事！因为如果你…</p><div class="PostItem-Footer"><span>马佳鑫</span><span class="PostItem-FooterTitle">发表于程序员职场...</span></div></div></a><a href="https://zhuanlan.zhihu.com/p/73359755" class="PostItem"><div><h1 class="PostItem-Title">前端程序员饱和了吗？我们公司给初级前端开到了12K</h1><p class="PostItem-Summary">故事起因： 最近我有个刚毕业的学生问我说：我感觉现在前端行业已经饱和了，也不是说饱和了，是初级的前端根本就没有公司要，哪怕你不要工资也没公司要你，前端刚学出来，没有任何的项目经…</p><div class="PostItem-Footer"><span>正等正觉</span><span class="PostItem-FooterTitle">发表于Java学...</span></div></div></a><a href="https://zhuanlan.zhihu.com/p/71131981" class="PostItem"><div><h1 class="PostItem-Title">产品经理与程序员打架, 公司处理结果，网友笑死</h1><p class="PostItem-Summary">在互联网公司里面，若把他们最讨厌的人排出个123来，产品经理绝对能进前3。对于产品经理们各种奇葩需求，无休止的修改让程序员们苦不堪言。不只是临时增加需求，一些项目经理在需求表达上，…</p><div class="PostItem-Footer"><span>前端彭于晏</span><span class="PostItem-FooterTitle"></span></div></div></a><button class="PagingButton PagingButton-Next" data-za-detail-view-path-module="Unknown" data-za-detail-view-path-module_name="推荐阅读" data-za-extra-module="{}"><svg class="Zi Zi--ArrowRight" fill="#d3d3d3" viewBox="0 0 24 24" width="40" height="40"><path d="M9.218 16.78a.737.737 0 0 0 1.052 0l4.512-4.249a.758.758 0 0 0 0-1.063L10.27 7.22a.737.737 0 0 0-1.052 0 .759.759 0 0 0-.001 1.063L13 12l-3.782 3.716a.758.758 0 0 0 0 1.063z" fill-rule="evenodd"></path></svg></button></ul></div><div class="Comments-container" data-za-detail-view-path-module="CommentList" data-za-extra-module="{}"><div class="CommentsV2 CommentsV2--withEditor CommentsV2-withPagination"><div class="Topbar CommentTopbar"><div class="Topbar-title"><h2 class="CommentTopbar-title">还没有评论</h2></div><div class="Topbar-options"></div></div><div><div class="CommentsV2-footer CommentEditorV2--normal"><div class="CommentEditorV2-inputWrap"><div class="InputLike CommentEditorV2-input Editable"><div class="Dropzone Editable-content RichText RichText--editable RichText--clearBoth ztext" style="min-height: 198px;"><div class="DraftEditor-root"><div class="public-DraftEditorPlaceholder-root"><div class="public-DraftEditorPlaceholder-inner" id="placeholder-apen2" style="white-space: pre-wrap;">写下你的评论...</div></div><div class="DraftEditor-editorContainer"><div aria-describedby="placeholder-apen2" class="notranslate public-DraftEditor-content" contenteditable="true" role="textbox" spellcheck="true" tabindex="0" style="outline: none; user-select: text; white-space: pre-wrap; overflow-wrap: break-word;"><div data-contents="true"><div class="Editable-unstyled" data-block="true" data-editor="apen2" data-offset-key="d0oms-0-0"><div data-offset-key="d0oms-0-0" class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span data-offset-key="d0oms-0-0"><br data-text="true"></span></div></div></div></div></div></div></div><input multiple="" type="file" accept="image/jpg,image/jpeg,image/png,image/gif" style="display: none;"><div></div></div><div class="CommentEditorV2-inputUpload"><div class="CommentEditorV2-popoverWrap"><div class="Popover CommentEditorV2-inputUpLoad-Icon"><button aria-label="插入表情" data-tooltip="插入表情" data-tooltip-position="bottom" data-tooltip-will-hide-on-click="true" id="Popover11-toggle" aria-haspopup="true" aria-expanded="false" aria-owns="Popover11-content" type="button" class="Button Editable-control Button--plain"><svg class="Zi Zi--Emotion" fill="currentColor" viewBox="0 0 24 24" width="24" height="24"><path d="M7.523 13.5h8.954c-.228 2.47-2.145 4-4.477 4-2.332 0-4.25-1.53-4.477-4zM12 21a9 9 0 1 1 0-18 9 9 0 0 1 0 18zm0-1.5a7.5 7.5 0 1 0 0-15 7.5 7.5 0 0 0 0 15zm-3-8a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm6 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z"></path></svg></button></div></div></div></div><button type="button" disabled="" class="Button CommentEditorV2-singleButton Button--primary Button--blue">发布</button></div></div><div><div class="CommentListV2"></div></div></div></div></div></div></main><div class="CornerButtons"><div class="CornerAnimayedFlex"><button data-tooltip="回到顶部" data-tooltip-position="left" data-tooltip-will-hide-on-click="true" aria-label="回到顶部" type="button" class="Button CornerButton Button--plain"><svg class="Zi Zi--BackToTop" aria-label="回到顶部" fill="currentColor" viewBox="0 0 24 24" width="24" height="24"><path d="M16.036 19.59a1 1 0 0 1-.997.995H9.032a.996.996 0 0 1-.997-.996v-7.005H5.03c-1.1 0-1.36-.633-.578-1.416L11.33 4.29a1.003 1.003 0 0 1 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.005z"></path></svg></button></div></div></div></div><script nonce="" async="" src="https://www.googletagmanager.com/gtag/js?id=UA-149949619-1"></script><script nonce="">function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-149949619-1");gtag('set', {'user_id': '967865b912bde7a071705f71793cf75a'});gtag('event', 'login', {'event_category': 'engagement'});</script><script id="js-clientConfig" type="text/json">{"host":"zhihu.com","protocol":"https:","wwwHost":"www.zhihu.com","fetchRoot":{"www":"https:\u002F\u002Fwww.zhihu.com","api":"https:\u002F\u002Fapi.zhihu.com","zhuanlan":"https:\u002F\u002Fzhuanlan.zhihu.com"}}</script><script id="js-initialData" type="text/json">{"initialState":{"common":{"ask":{}},"loading":{"global":{"count":0},"local":{"env\u002FgetIpinfo\u002F":false,"article\u002Fget\u002F":false,"brand\u002FgetUrl\u002F":false}},"club":{"tags":{},"admins":{"data":[]},"members":{"data":[]},"explore":{},"profile":{},"checkin":{},"comments":{"paging":{},"loading":{},"ids":{}},"postList":{"paging":{},"loading":{},"ids":{}},"recommend":{"data":[]},"silences":{"data":[]},"application":{"profile":null}},"entities":{"users":{"967865b912bde7a071705f71793cf75a":{"uid":1005482279677943800,"userType":"people","id":"967865b912bde7a071705f71793cf75a"},"bu-fan-xue-yuan-34":{"isFollowed":false,"avatarUrlTemplate":"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-2f9551216fc17270ec6eeaecad8999d3.jpg?source=172ae18b","uid":"1029071864857051136","userType":"organization","isFollowing":false,"urlToken":"bu-fan-xue-yuan-34","id":"400402bacda73eb00f80f229df780707","description":"不凡学院由国内一线互联网从业者发起，专注为国内互联网输送优质人才，踏踏实实做教育，把教学放在首位，不虚假承诺，不虚假宣传，让学员真正学到知识，以真实的实际项目为核心，保证学员的技术胜任工作！","name":"不凡学院","isAdvertiser":false,"headline":"一家耿直、靠谱的互联网培训机构。bufanui.com","gender":1,"url":"\u002Forg\u002F400402bacda73eb00f80f229df780707","avatarUrl":"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-2f9551216fc17270ec6eeaecad8999d3_l.jpg?source=172ae18b","isOrg":true,"type":"people","badge":[{"type":"identity","topics":[],"description":"已认证的官方帐号"}],"badgeV2":{"title":"已认证的官方帐号","mergedBadges":[{"type":"identity","detailType":"identity","title":"认证","description":"已认证的官方帐号","url":"https:\u002F\u002Fwww.zhihu.com\u002Faccount\u002Fverification\u002Fintro","sources":[],"icon":""}],"detailBadges":[{"type":"identity","detailType":"identity_org","title":"已认证的官方帐号","description":"已认证的官方帐号","url":"https:\u002F\u002Fwww.zhihu.com\u002Faccount\u002Fverification\u002Fintro","sources":[],"icon":"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-235258cecb8a0f184c4d38483cd6f6b6_l.png"}],"icon":"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-235258cecb8a0f184c4d38483cd6f6b6_l.png"}}},"questions":{},"answers":{},"articles":{"130905785":{"trackUrl":["https:\u002F\u002Fsugar.zhihu.com\u002Fplutus_adreaper\u002Fpage_monitor_log?si=__SESSIONID__&ti=__ATOKEN__&at=view&pf=__OS__&ed=BiBUKF0xBSkqGGNfCWh9Alt9C1A9R7PCy5sz&idfa=__IDFA__&imei=__IMEI__&androidid=__ANDROIDID__&oaid=__OAID__&ci=__CREATIVEID__&zid=__ZONEID__"],"id":130905785,"title":"😀前端入门操作系统知识，这一篇就够啦！","type":"article","articleType":"normal","excerptTitle":"","url":"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F130905785","imageUrl":"","titleImage":"","excerpt":"\u003Cimg src=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-3d7bf71428d8ce8371652bb4c52a01a1_200x112.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"590\" data-rawheight=\"509\" data-watermark=\"original\" data-original-src=\"v2-3d7bf71428d8ce8371652bb4c52a01a1\" data-watermark-src=\"v2-9065886a0a9d53c2cd66f951df83add0\" data-private-watermark-src=\"\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-3d7bf71428d8ce8371652bb4c52a01a1_r.jpg\" class=\"origin_image inline-img zh-lightbox-thumb\"\u002F\u003E此文针对非科班同学来补充程序猿必备的基础知识。 \u003Ca href=\"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F112777391\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\"\u003E不凡学院： 前端需要了解的计算机网络知识， 这一篇就够了！(图文并茂，万字长文，点赞收藏哦！)\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F112514996\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\"\u003E不凡学院：【非科班前端】注意了！ 计算机组成原理知识已送到你嘴边!\u003C\u002Fa\u003E 好了，开撸操作系统！ \u003Cb\u003E弱弱的问一问: …\u003C\u002Fb\u003E","created":1586942415,"updated":1586942415,"author":{"isFollowed":false,"avatarUrlTemplate":"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-2f9551216fc17270ec6eeaecad8999d3.jpg?source=172ae18b","uid":"1029071864857051136","userType":"organization","isFollowing":false,"urlToken":"bu-fan-xue-yuan-34","id":"400402bacda73eb00f80f229df780707","description":"不凡学院由国内一线互联网从业者发起，专注为国内互联网输送优质人才，踏踏实实做教育，把教学放在首位，不虚假承诺，不虚假宣传，让学员真正学到知识，以真实的实际项目为核心，保证学员的技术胜任工作！","name":"不凡学院","isAdvertiser":false,"headline":"一家耿直、靠谱的互联网培训机构。bufanui.com","gender":1,"url":"\u002Forg\u002F400402bacda73eb00f80f229df780707","avatarUrl":"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-2f9551216fc17270ec6eeaecad8999d3_l.jpg?source=172ae18b","isOrg":true,"type":"people","badge":[{"type":"identity","topics":[],"description":"已认证的官方帐号"}],"badgeV2":{"title":"已认证的官方帐号","mergedBadges":[{"type":"identity","detailType":"identity","title":"认证","description":"已认证的官方帐号","url":"https:\u002F\u002Fwww.zhihu.com\u002Faccount\u002Fverification\u002Fintro","sources":[],"icon":""}],"detailBadges":[{"type":"identity","detailType":"identity_org","title":"已认证的官方帐号","description":"已认证的官方帐号","url":"https:\u002F\u002Fwww.zhihu.com\u002Faccount\u002Fverification\u002Fintro","sources":[],"icon":"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-235258cecb8a0f184c4d38483cd6f6b6_l.png"}],"icon":"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-235258cecb8a0f184c4d38483cd6f6b6_l.png"}},"commentPermission":"all","copyrightPermission":"need_review","state":"published","imageWidth":0,"imageHeight":0,"content":"\u003Cp\u003E此文针对非科班同学来补充程序猿必备的基础知识。\u003Cbr\u002F\u003E \u003C\u002Fp\u003E\u003Ca href=\"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F112777391\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\"\u003E不凡学院： 前端需要了解的计算机网络知识， 这一篇就够了！(图文并茂，万字长文，点赞收藏哦！)\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F112514996\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\"\u003E不凡学院：【非科班前端】注意了！ 计算机组成原理知识已送到你嘴边!\u003C\u002Fa\u003E\u003Cp\u003E\u003Cbr\u002F\u003E \u003C\u002Fp\u003E\u003Cp\u003E 好了，开撸操作系统！\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-2cf128731dfb1c8ebd23d2b0e3fcaec4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"177\" data-rawheight=\"163\" class=\"content_image\" width=\"177\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;177&#39; height=&#39;163&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"177\" data-rawheight=\"163\" class=\"content_image lazy\" width=\"177\" data-actualsrc=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-2cf128731dfb1c8ebd23d2b0e3fcaec4_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E弱弱的问一问: 要操作系统干嘛？\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E这里先不讲\u003Ccode\u003E操作系统\u003C\u002Fcode\u003E的概念了，因为文字太生硬了，我们只需要看一个简单的例子：\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E在我们的JS代码里，只需要输入 \u003Ccode\u003Econsole.log(1+1)\u003C\u002Fcode\u003E; 就可以在浏览器面板中看到\u003Ccode\u003E2\u003C\u002Fcode\u003E，这其中发生了什么事情呢?(简单扫一眼)\u003C\u002Fli\u003E\u003Cli\u003E首先键盘输入代码\u003Ccode\u003E1+1\u003C\u002Fcode\u003E到显示器输出\u003Ccode\u003E2\u003C\u002Fcode\u003E, 需要\u003Ccode\u003ECPU\u003C\u002Fcode\u003E控制键盘（输入设备） ，将获取的\u003Ccode\u003E1+1\u003C\u002Fcode\u003E指令放入内存\u003C\u002Fli\u003E\u003Cli\u003E然后CPU的控制器从内存中取出指令，并分析出指令是让计算机做一个\u003Ccode\u003E1+1\u003C\u002Fcode\u003E的加法运算\u003C\u002Fli\u003E\u003Cli\u003E此时CPU的控制将控制CPU的运算器做\u003Ccode\u003E1+1\u003C\u002Fcode\u003E的加法运算，并得出结果\u003Ccode\u003E2\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\u003Cli\u003E最后CPU控制器控制运算器将结果返给内存，内存也在CPU控制器的控制下，将结果\u003Ccode\u003E2\u003C\u002Fcode\u003E返回给屏幕（输出设备）\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E好了，这里问题是，如果没有操作系统，一个简单的1+1运算，你的js代码还需要考虑这些硬件的协调工作，比如你的代码要协调CPU资源什么时候读取你的代码，什么时候把进程切换到别的进程。。。这些脏活累活都是操作系统帮你屏蔽了，要不这代码可咋写啊。。。\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-3d7bf71428d8ce8371652bb4c52a01a1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"590\" data-rawheight=\"509\" class=\"origin_image zh-lightbox-thumb\" width=\"590\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-3d7bf71428d8ce8371652bb4c52a01a1_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;590&#39; height=&#39;509&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"590\" data-rawheight=\"509\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"590\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-3d7bf71428d8ce8371652bb4c52a01a1_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-3d7bf71428d8ce8371652bb4c52a01a1_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E弱弱的问一问: 前端学这个干嘛？\u003C\u002Fp\u003E\u003Cp\u003E很早以前看朴零大神的《深入浅出NodeJS》的时候，讲到进程间通信，有一句大概说，windows平台进程间通信用的是管道，linux平台用的是domain socket，我一看就傻眼了，啥是进程间通信？啥是管道？啥是domain socket？  看不懂啊....  这些都是跟操作系统进程的知识相关）。\u003C\u002Fp\u003E\u003Cp\u003E啥也了不说了，兄弟，学习的小车已经粗发了！\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-fe4d84f07dadfa898c023c92586a5d8a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"450\" class=\"origin_image zh-lightbox-thumb\" width=\"845\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-fe4d84f07dadfa898c023c92586a5d8a_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;845&#39; height=&#39;450&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"450\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"845\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-fe4d84f07dadfa898c023c92586a5d8a_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-fe4d84f07dadfa898c023c92586a5d8a_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E1、操作系统的四个特征\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E有以下四个特征：\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E并发\u003C\u002Fli\u003E\u003Cli\u003E共享\u003C\u002Fli\u003E\u003Cli\u003E虚拟\u003C\u002Fli\u003E\u003Cli\u003E异步\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E 接下来，我们分别来搞定每一个特征。\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E1.1 并发是什么？和并行有啥区别？\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E举个例子，假如你在语音跟同学玩英雄联盟：\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E你一边用鼠标移动打游戏，同时语音嘴里说&#34;队友挂机，真坑！&#34;, 这叫并行（边移动鼠标边语音BB）\u003C\u002Fli\u003E\u003Cli\u003E你一边用鼠标移动打游戏，然后离开鼠标，去砸键盘, 这叫并发（先离开鼠标然后砸键盘\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E并发只是把时间分成若干段，\u003Ccode\u003E使多个任务交替的执行\u003C\u002Fcode\u003E。 并行的关键是你有\u003Ccode\u003E同时处理\u003C\u002Fcode\u003E多个任务的能力。\u003Cbr\u002F\u003E \u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E所以我认为它们最关键的点就是：\u003Ccode\u003E是否是『同时』\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E那么对于操作系统而言，操作系统的并发性指计算机系统中\u003Ccode\u003E同时存在多个运行着的程序\u003C\u002Fcode\u003E。\u003Cbr\u002F\u003E \u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E 比如说以前的计算机是单核CPU，那么如何在操作系统上同时运行QQ、浏览器，记事本、ppt等多个程序呢，这就需要操作系统具有并发性\u003Cbr\u002F\u003E \u003C\u002Fli\u003E\u003Cli\u003E\u003Ccode\u003ECPU时间\u003C\u002Fcode\u003E片（操作系统分配给每个正在运行的进程微观上的一段CPU时间）轮着给进程执行的时间，因为执行速度很快，\u003Ccode\u003E看起来就像\u003C\u002Fcode\u003E浏览器能同时执行任务一样。\u003Cbr\u002F\u003E \u003C\u002Fli\u003E\u003Cli\u003E 有人会说，现在都多核CPU了，还需要并发吗，答案肯定是需要的，比如你有8核CPU，但是桌面要执行的任务很可能超过8个。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E1.2 共享是什么？共享和并发有什么关系？\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E举一个例子： 你同时用QQ和微信发&#34;年终述职.ppt&#34;文件给领导，这时候QQ和微信都在读取这个ppt文件\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E两个进程正在并发执行（并发性）\u003C\u002Fli\u003E\u003Cli\u003E需要共享地访问硬盘资源（共享性） 如果没有并发，也就是只有一个进程在运行，那就没有共享了。如果没有共享，QQ和微信就不能同时发文件，无法同时访问硬盘资源，也就无法并发。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E其中共享分为两种情况：\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-06bcbe0251301f0c15f1afd61d50aaa8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"325\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-06bcbe0251301f0c15f1afd61d50aaa8_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;325&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"325\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-06bcbe0251301f0c15f1afd61d50aaa8_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-06bcbe0251301f0c15f1afd61d50aaa8_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cbr\u002F\u003E \u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E上面的例子，QQ和微信都要访问同一个文件，属于\u003Ccode\u003E同时共享\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E对于互斥共享，比如打印机，\u003Ccode\u003E只能同一时刻被一个进程控制\u003C\u002Fcode\u003E，如打印机，虽然他可以提供多个进程使用，但是试想，同时打印多个东西，会造成打印结果的混乱，因此规定，某些资源在进行使用的时候，必须要先让某进程先使用，等使用完之后，再同一其他进程进行访问。\u003C\u002Fli\u003E\u003Cli\u003E我们把一段时间内只允许一个进程访问的资源称为\u003Ccode\u003E独占资源\u003C\u002Fcode\u003E，或\u003Ccode\u003E临界资源\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E1.3 虚拟是啥？\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E先举例，再说定义。\u003C\u002Fp\u003E\u003Cp\u003E假如一个叫\u003Ccode\u003E范桶\u003C\u002Fcode\u003E的货车司机在玩英雄联盟，平时因为酒驾太多，自己装了很多次别人的车，住院也花了不少钱，所以家里没钱，只能买个\u003Ccode\u003E1G内存\u003C\u002Fcode\u003E的二手电脑玩游戏。可\u003Ccode\u003E英雄联盟\u003C\u002Fcode\u003E至少需要\u003Ccode\u003E2G内存\u003C\u002Fcode\u003E，这就奇怪了，老司机虽然一到团战就卡死，但是还是能运行英雄联盟。为什么需要\u003Ccode\u003E2G内存\u003C\u002Fcode\u003E的游戏，\u003Ccode\u003E1G电脑\u003C\u002Fcode\u003E还能运行呢？\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-e4612e1924920eda9b8eaa5b2d1691f8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"492\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-e4612e1924920eda9b8eaa5b2d1691f8_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;500&#39; height=&#39;492&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"492\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-e4612e1924920eda9b8eaa5b2d1691f8_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-e4612e1924920eda9b8eaa5b2d1691f8_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E这就是虚拟存储器技术。实际上\u003Ccode\u003E只有1G内存\u003C\u002Fcode\u003E，在用户看来\u003Ccode\u003E远远大于1G\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\u003Cp\u003E还有，\u003Ccode\u003E范桶\u003C\u002Fcode\u003E的电脑还是\u003Ccode\u003E单核的\u003C\u002Fcode\u003E，但\u003Ccode\u003E范桶\u003C\u002Fcode\u003E居然能一边迅雷下着爱情动作片，一边听着网易云音乐，还在QQ上撩妹子，既然一个程序要被分配CPU才能正常执行，按道理来说同一时间只有1个程序在运行，为啥电脑能同时运行这么多程序呢？\u003C\u002Fp\u003E\u003Cp\u003E这就是虚拟处理器技术。实际上只有\u003Ccode\u003E一个CPU\u003C\u002Fcode\u003E，在用户看来有\u003Ccode\u003E3个CPU\u003C\u002Fcode\u003E在同时服务。（因为CPU来回切换进程的速度特别块，感觉就像很多CPU在为我们服务）\u003C\u002Fp\u003E\u003Cp\u003E虚拟这块的总结如下:\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-4b1a275914866d978473d169c72b439a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1269\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb\" width=\"1269\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-4b1a275914866d978473d169c72b439a_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1269&#39; height=&#39;489&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1269\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1269\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-4b1a275914866d978473d169c72b439a_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-4b1a275914866d978473d169c72b439a_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E1.4 异步性是啥?\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E异步在JS里是很常见的，比如\u003Ccode\u003Eajax请\u003C\u002Fcode\u003E求，我们发出请求后并不是立马得到信息，也不会去等待\u003Ccode\u003Eajax\u003C\u002Fcode\u003E结果返回，而是继续执行下面的代码，等ajax结果回来，通知\u003Ccode\u003EJS线程\u003C\u002Fcode\u003E。这就跟\u003Ccode\u003ECPU处理进程\u003C\u002Fcode\u003E很类似。\u003C\u002Fp\u003E\u003Cp\u003E比如，CPU正在执行一个进程，进程需要读取文件，读取文件可能要\u003Ccode\u003E1个小时\u003C\u002Fcode\u003E，那CPU不可能一直等一个小时，CPU会继续把时间片分给别的进程，等文件读取完成了（类似ajax返回结果了），\u003Ccode\u003ECPU再继续执行\u003C\u002Fcode\u003E之前被\u003Ccode\u003E中断\u003C\u002Fcode\u003E的进程。\u003C\u002Fp\u003E\u003Cp\u003E所以异步性就是描述进程这种以不可预知的速度走走停停、何时开始何时暂停何时结束不可预知的性质。\u003Cbr\u002F\u003E\u003Cbr\u002F\u003E\u003Cb\u003E2、操作系统运行机制和体系结构\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E预备知识： 什么是指令\u003C\u002Fp\u003E\u003Cp\u003E比如说，如下图（简单扫一下即可）：\u003C\u002Fp\u003E\u003Cp class=\"ztext-empty-paragraph\"\u003E\u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-b552286ba02148a7cb8babe4af1b4f04_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"563\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb\" width=\"563\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-b552286ba02148a7cb8babe4af1b4f04_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;563&#39; height=&#39;170&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"563\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"563\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-b552286ba02148a7cb8babe4af1b4f04_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-b552286ba02148a7cb8babe4af1b4f04_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003Ea+b是一段程序代码，a+b在CPU看来并不能一步完成，可以翻译成如下：\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-text\"\u003E\u002F\u002F 意思是将内存的16号单元数据，放到A寄存器，\nLOAD A, 16\n\u002F\u002F 意思是将内存的16号单元数据，放到B寄存器\nLOAD B, 17\n\u002F\u002F 存器里的A,B数据相加，得到C\nADD C, A, B\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E这里就可以看得出来，指令是\u003Ccode\u003ECPU\u003C\u002Fcode\u003E能\u003Ccode\u003E识别\u003C\u002Fcode\u003E和\u003Ccode\u003E执行\u003C\u002Fcode\u003E的最基本命令。\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E2.1 两种指令、两种处理器状态、两种程序\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E假如说一个用户可以随意把服务器上的所有文件删光，这是很危险的。所以有些指令普通用户是不能使用的，只能是\u003Ccode\u003E权限较高\u003C\u002Fcode\u003E的用户能使用。此时指令就分为了两种，如下图：\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-bf6450e944a269b5efef95f1e5eb0364_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"299\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-bf6450e944a269b5efef95f1e5eb0364_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;299&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"299\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-bf6450e944a269b5efef95f1e5eb0364_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-bf6450e944a269b5efef95f1e5eb0364_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E这就引出一个问题：CPU\u003Ccode\u003E如何判断\u003C\u002Fcode\u003E当前是否可以执行\u003Ccode\u003E特权指令\u003C\u002Fcode\u003E？ 如下图: \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-97d8a13c43a6d5a513997aad4c793dd1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"293\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-97d8a13c43a6d5a513997aad4c793dd1_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;293&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"293\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-97d8a13c43a6d5a513997aad4c793dd1_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-97d8a13c43a6d5a513997aad4c793dd1_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003ECPU通常有两种工作模式即：\u003Ccode\u003E内核态\u003C\u002Fcode\u003E和\u003Ccode\u003E用户态\u003C\u002Fcode\u003E，而在PSW（这个不用管，就知道有一个寄存器的标志位0表示用户态，1表示核心态）中有一个二进制位控制这两种模式。\u003C\u002Fp\u003E\u003Cp\u003E对于应用程序而言，有的程序能执行特权指令，有的程序只能执行非特权指令。所以操作系统里的程序又分为两种：\u003C\u002Fp\u003E\u003Cp class=\"ztext-empty-paragraph\"\u003E\u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-005afaad33a3a6f99997ec912225773e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"422\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-005afaad33a3a6f99997ec912225773e_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;422&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"422\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-005afaad33a3a6f99997ec912225773e_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-005afaad33a3a6f99997ec912225773e_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp class=\"ztext-empty-paragraph\"\u003E\u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Ch3\u003E2.2 操作系统内核简单介绍\u003C\u002Fh3\u003E\u003Cp\u003E从下图，我们先看看操作系统内核包含哪些\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-74317e6fd6ccab652f5b6747524b58ea_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"465\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-74317e6fd6ccab652f5b6747524b58ea_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;465&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"465\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-74317e6fd6ccab652f5b6747524b58ea_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-74317e6fd6ccab652f5b6747524b58ea_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E操作系统内核中跟硬件紧密相关的部分有：\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E时钟管理。操作系统的时钟管理是依靠\u003Ccode\u003E硬件定时器\u003C\u002Fcode\u003E的（具体硬件怎么实现我也不太清楚，好像是靠硬件周期性的产生一个脉冲信号实现的）。时钟管理相当重要，比如我们\u003Ccode\u003E获取时间信息\u003C\u002Fcode\u003E，\u003Ccode\u003E进程切换\u003C\u002Fcode\u003E等等都是要依靠时钟管理。\u003C\u002Fli\u003E\u003Cli\u003E中断处理（下一小节会详细介绍）。\u003C\u002Fli\u003E\u003Cli\u003E原语（后面会有案例提到）。现在可以简单理解为用来实现某个特定功能，在执行过程中\u003Ccode\u003E不可被中断\u003C\u002Fcode\u003E的指令集合。原语有一个非常重要的特性，就是原子性（其运行\u003Ccode\u003E一气呵成，不可中断\u003C\u002Fcode\u003E）。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E 2.3 中断\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU\u003Ccode\u003E暂时中止程序的执行\u003C\u002Fcode\u003E转而\u003Ccode\u003E处理这个新的情况\u003C\u002Fcode\u003E的过程就叫做\u003Ccode\u003E中断\u003C\u002Fcode\u003E。 下面举一个例子：\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp class=\"ztext-empty-paragraph\"\u003E\u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-8461e2892594360e6cec6d0d1f5c4789_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"573\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-8461e2892594360e6cec6d0d1f5c4789_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;573&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"573\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-8461e2892594360e6cec6d0d1f5c4789_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-8461e2892594360e6cec6d0d1f5c4789_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E第一个应用程序在用户态执行了一段时间后 \u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-43cdd9e32d0d61174d8f914ff4280ccb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"556\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-43cdd9e32d0d61174d8f914ff4280ccb_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;556&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"556\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-43cdd9e32d0d61174d8f914ff4280ccb_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-43cdd9e32d0d61174d8f914ff4280ccb_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E接着操作系统切换到核心态，处理中断信号 \u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-f07196e25b42671a798bfeaf55bb773b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"603\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-f07196e25b42671a798bfeaf55bb773b_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;603&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"603\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-f07196e25b42671a798bfeaf55bb773b_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-f07196e25b42671a798bfeaf55bb773b_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cbr\u002F\u003E \u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E操作系统发现\u003Ccode\u003E中断的信号\u003C\u002Fcode\u003E是第一个程序的时间片（每个程序不能一直执行，CPU会给每个程序一定的执行时间，这段时间就是时间片）用完了，应该换第二个应用程序执行了\u003C\u002Fli\u003E\u003Cli\u003E切换到\u003Ccode\u003E第2个进程\u003C\u002Fcode\u003E后，操作系统会将\u003Ccode\u003ECPU\u003C\u002Fcode\u003E的\u003Ccode\u003E使用权\u003C\u002Fcode\u003E交换给第二个应用程序，接着第二个应用程序就在\u003Ccode\u003E用户态\u003C\u002Fcode\u003E下开始执行。\u003C\u002Fli\u003E\u003Cli\u003E\u003Ccode\u003E进程\u003C\u002Fcode\u003E2需要调用\u003Ccode\u003E打印机资源\u003C\u002Fcode\u003E，这时会执行一个\u003Ccode\u003E系统调用\u003C\u002Fcode\u003E（后面会讲系统调用，这里简单理解为需要操作系统进入核心态处理的函数），让操作系统进入核心态，去调用打印机资源\u003C\u002Fli\u003E\u003Cli\u003E打印机开始工作，\u003Ccode\u003E此时进程2\u003C\u002Fcode\u003E因为要等待打印机启动，操作系统就不等待了（等到打印机准备好了，再回来执行程序2），直接切换到\u003Ccode\u003E第三个应用程序\u003C\u002Fcode\u003E执行\u003C\u002Fli\u003E\u003Cli\u003E等到打印机准备好了，此时打印机通过I\u002FO控制器会给操作系统发出一\u003Ccode\u003E个中断信号\u003C\u002Fcode\u003E，操作系统又进入到核心态，发现这个中断是因为\u003Ccode\u003E程序2\u003C\u002Fcode\u003E等待打印机资源，现在打印机准备好了，就切换到\u003Ccode\u003E程序2\u003C\u002Fcode\u003E，切换到\u003Ccode\u003E用户态\u003C\u002Fcode\u003E，把CPU给程序2继续执行。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E 好了，现在可以给出一个结论，就是用户态、核心态之间的切换是怎么实现的?\u003Cbr\u002F\u003E \u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E&#34;用户态 ---&gt; 核心态&#34;是通过中断实现的。\u003Ccode\u003E并且中断时唯一途径\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E&#34;核心态 ---&gt; 用户态&#34;的切换时通过执行一个特权指令，将程序状态的标志位设为用户态\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E2.4 中断的分类\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E举一个例子，什么是内中断和外中断：\u003C\u002Fp\u003E\u003Cp\u003E接着说之前的范桶同学，小时候不爱学习，每次学习着学习着突然异想天开，回过神来已经过好好长一段时间，这是\u003Ccode\u003E内部中断\u003C\u002Fcode\u003E。想着想着老师走过来，给了范捅一嘴巴，这是\u003Ccode\u003E外部中断\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\u003Cp\u003E官方解释如下： \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-378e8758492b0c99565f1ea068080fda_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"505\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-378e8758492b0c99565f1ea068080fda_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;505&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"505\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-378e8758492b0c99565f1ea068080fda_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-378e8758492b0c99565f1ea068080fda_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E内中断常见的情况如\u003Ccode\u003E程序非法操作\u003C\u002Fcode\u003E(比如你要拿的的数据的内存地址不是内存地址，是系统无法识别的地址)，\u003Ccode\u003E地址越界\u003C\u002Fcode\u003E(比如系统给你的程序分配了一些内存，但是你访问的时候超出了你应该访问的内存范围)、\u003Ccode\u003E浮点溢出\u003C\u002Fcode\u003E(比如系统只能表示1.1到5.1的范围，你输入一个100, 超出了计算机能处理的范围)，或者\u003Ccode\u003E异常\u003C\u002Fcode\u003E，\u003Ccode\u003E陷入trap\u003C\u002Fcode\u003E（是指应用程序请求系统调用造成的，什么是系统调用，后面小节会举例讲）。\u003C\u002Fli\u003E\u003Cli\u003E外中断常见的情况如\u003Ccode\u003EI\u002FO中断\u003C\u002Fcode\u003E（由I\u002FO控制器产生，用于发送信号通知操作完成等信号，比如进程需要请求打印机资源，打印机有一个启动准备的过程，准备好了就会给CPU一个I\u002FO中断，告诉它已经准备好了）、\u003Ccode\u003E时钟中断\u003C\u002Fcode\u003E（由处理器内部的计时器产生，允许操作系统以一定规程执行函数，操作系统每过大约15ms会进行一次线程调度，就是利用时钟中断来实现的）。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E2.5 系统调用\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E为什么需要系统调用？\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E 比如你的程序需要\u003Ccode\u003E读取文件信息\u003C\u002Fcode\u003E，可读取文件属于\u003Ccode\u003E读取硬盘里的数\u003C\u002Fcode\u003E据，这个操作应该时CPU在\u003Ccode\u003E内核态\u003C\u002Fcode\u003E去完成的，我们的应用程序怎么让CPU去帮助我们切换到内核态完成这个工作呢，这里就需要\u003Ccode\u003E系统调用了\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E 这里就引出系统调用的概念和作用。\u003C\u002Fli\u003E\u003Cli\u003E 应用程序\u003Ccode\u003E通过系统调用请求操作系统的服务\u003C\u002Fcode\u003E。系统中的各种共享资源都由操作系统统一管理，因此在用户程序中，凡是与\u003Ccode\u003E资源有关的操作\u003C\u002Fcode\u003E（如存储分配、I\u002FO操作、文件管理等），都\u003Ccode\u003E必须\u003C\u002Fcode\u003E通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E以下内容简单看一下即可，系统调用的分类：\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-a92b936b9a7ed4a90d949915f381397e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-a92b936b9a7ed4a90d949915f381397e_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;398&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-a92b936b9a7ed4a90d949915f381397e_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-a92b936b9a7ed4a90d949915f381397e_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E需要注意的是，\u003Ccode\u003E库函数\u003C\u002Fcode\u003E和\u003Ccode\u003E系统调用\u003C\u002Fcode\u003E容易混淆。\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E库是可重用的模块 \u003Ccode\u003E处于用户态\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\u003Cli\u003E进程通过系统调用从用户态进入\u003Ccode\u003E内核态\u003C\u002Fcode\u003E， 库函数中有很大部分是对系统调用的封装\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E举个例子：比如\u003Ccode\u003Ewindows\u003C\u002Fcode\u003E和\u003Ccode\u003Elinux\u003C\u002Fcode\u003E中，创建进程的系统调用方法是不一样的。 但在node中的只需要调用相同函数方法就可以创建一个进程。例如\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"c1\"\u003E\u002F\u002F 引入创建子进程的模块\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"kr\"\u003Econst\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003EchildProcess\u003C\u002Fspan\u003E \u003Cspan class=\"o\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Erequire\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"s1\"\u003E&#39;child_process&#39;\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E)\u003C\u002Fspan\u003E\n\u003Cspan class=\"c1\"\u003E\u002F\u002F 获取cpu的数量\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"kr\"\u003Econst\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003EcpuNum\u003C\u002Fspan\u003E \u003Cspan class=\"o\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Erequire\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"s1\"\u003E&#39;os&#39;\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E).\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Ecpus\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E().\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Elength\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"c1\"\u003E\u002F\u002F 创建与cpu数量一样的子进程\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"k\"\u003Efor\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"kd\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Ei\u003C\u002Fspan\u003E \u003Cspan class=\"o\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"mi\"\u003E0\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E;\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Ei\u003C\u002Fspan\u003E \u003Cspan class=\"o\"\u003E&lt;\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003EcpuNum\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E;\u003C\u002Fspan\u003E \u003Cspan class=\"o\"\u003E++\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Ei\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"nx\"\u003EchildProcess\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Efork\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"s1\"\u003E&#39;.\u002Fworker.js&#39;\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E)\u003C\u002Fspan\u003E\n\u003Cspan class=\"p\"\u003E}\u003C\u002Fspan\u003E\n\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E\u003Cb\u003E2.6 进程的定义、组成、组织方式、状态与转换\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E2.6.1 为什么要引入进程的概念呢？\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E早期的计算机只支持\u003Ccode\u003E单道程序\u003C\u002Fcode\u003E（是指所有进程一个一个排队执行，A进程执行时，CPU、内存、I\u002FO设备全是A进程控制的，等A进程执行完了，才换B进程，然后对应的资源比如CPU、内存这些才能换B用）。 \u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-226d1652b70581a24ebe4e9a05ef2d2a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1188\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb\" width=\"1188\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-226d1652b70581a24ebe4e9a05ef2d2a_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1188&#39; height=&#39;554&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1188\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1188\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-226d1652b70581a24ebe4e9a05ef2d2a_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-226d1652b70581a24ebe4e9a05ef2d2a_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E现代计算机是\u003Ccode\u003E多道程序\u003C\u002Fcode\u003E执行，就是同时看起来有多个程序在一起执行，那每个程序执行都需要系统分配给它资源来执行，比如\u003Ccode\u003ECPU\u003C\u002Fcode\u003E、\u003Ccode\u003E内存\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E拿内存来说，操作系统要知道给A程序分配的内存有哪些，给B程序分配的内存有哪些，这些都要有小本本记录下来，这个小本本就是进程的一部分，进程的一大职责就是\u003Ccode\u003E记录目前程序运行的状态\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E系统为每个运行的程序配置一个数据结构，称为\u003Ccode\u003E进程控制块\u003C\u002Fcode\u003E（PCB），用来描述进程的各种信息（比如代码段放在哪）。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E2.6.2 进程的定义？\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E简要的说，进程就是具有\u003Ccode\u003E独立功能的程序\u003C\u002Fcode\u003E在数据集合上\u003Ccode\u003E运行的过程\u003C\u002Fcode\u003E。(强调动态性)\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E2.6.3 PCB有哪些组成\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E如下图，分别说明一下 \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-6353e6e73e82b9807c1c8cd1aa098d76_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"787\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-6353e6e73e82b9807c1c8cd1aa098d76_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1000&#39; height=&#39;787&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"787\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-6353e6e73e82b9807c1c8cd1aa098d76_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-6353e6e73e82b9807c1c8cd1aa098d76_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E\u003Ccode\u003E进程标识符PID\u003C\u002Fcode\u003E相当于身份证。是在进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，\u003Ccode\u003E用于区分不同的进程\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E用户标识符\u003Ccode\u003EUID\u003C\u002Fcode\u003E用来表示这个进程\u003Ccode\u003E所属的用户\u003C\u002Fcode\u003E是谁。\u003C\u002Fli\u003E\u003Cli\u003E进程当前状态和优先级下一小节会详细介绍\u003C\u002Fli\u003E\u003Cli\u003E程序段指针是指当前进程的程序在\u003Ccode\u003E内存的什么地方\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E数据段指针是指当前进程的数据在\u003Ccode\u003E内存的什么地方\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E键盘和鼠标是指进程被\u003Ccode\u003E分配得到的I\u002FO设备\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E各种寄存器值是指比如把程序计数器的值，比如有些计算的结果算到一半，进程切换时需要把这些值保存下来。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E2.6.4 进程的组织\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E在一个系统中，通常由数十、数百乃至数千个\u003Ccode\u003EPCB\u003C\u002Fcode\u003E。为了对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。这里介绍一种组织方式，类似数据结构里的链表。\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-57b7ebf064e7590df53151f0b523f0c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"601\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-57b7ebf064e7590df53151f0b523f0c2_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;601&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"601\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-57b7ebf064e7590df53151f0b523f0c2_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-57b7ebf064e7590df53151f0b523f0c2_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cbr\u002F\u003E \u003Cb\u003E2.6.5 进程的状态\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E进程是程序的一次执行。\u003C\u002Fcode\u003E在这个执行过程中，有时进程正在\u003Ccode\u003E被CPU处理\u003C\u002Fcode\u003E，有时又需要\u003Ccode\u003E等待CPU服务\u003C\u002Fcode\u003E，可见，进程的 状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。\u003C\u002Fp\u003E\u003Cp\u003E进程的三种基本状态：\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-e65f0f2fd14744a26d1ab355d76f9b06_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"582\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-e65f0f2fd14744a26d1ab355d76f9b06_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;582&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"582\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-e65f0f2fd14744a26d1ab355d76f9b06_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-e65f0f2fd14744a26d1ab355d76f9b06_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E进程的另外两种状态：\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-fedc12e913c5d3a726e386db5836b3e0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-fedc12e913c5d3a726e386db5836b3e0_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;173&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-fedc12e913c5d3a726e386db5836b3e0_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-fedc12e913c5d3a726e386db5836b3e0_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E2.6.6 进程状态的转换\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E进程的状态并不是一成不变的，在一定情况下会动态转换。\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-2d74615cfad420b3ddbc023aefa2309a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"659\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-2d74615cfad420b3ddbc023aefa2309a_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;659&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"659\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-2d74615cfad420b3ddbc023aefa2309a_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-2d74615cfad420b3ddbc023aefa2309a_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E以上的这些进程状态的转换是如何实现的呢，这就要引出下一个角色了，叫`原语。\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E原语是\u003Ccode\u003E不可被中断\u003C\u002Fcode\u003E的原子操作。我们举一个例子看看原语是怎么保证不可中断的。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp class=\"ztext-empty-paragraph\"\u003E\u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-ca54d9ef9e1d89ac2071b49869c12bab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1218\" data-rawheight=\"580\" class=\"origin_image zh-lightbox-thumb\" width=\"1218\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-ca54d9ef9e1d89ac2071b49869c12bab_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1218&#39; height=&#39;580&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1218\" data-rawheight=\"580\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1218\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-ca54d9ef9e1d89ac2071b49869c12bab_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-ca54d9ef9e1d89ac2071b49869c12bab_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E原语采用\u003Ccode\u003E关中断指令\u003C\u002Fcode\u003E和\u003Ccode\u003E开中断指令\u003C\u002Fcode\u003E实现。\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E首先执行关中断指令\u003C\u002Fli\u003E\u003Cli\u003E然后外部来了中断信号，不予以处理\u003C\u002Fli\u003E\u003Cli\u003E等到开中断指令执行后，其他中断信号才有机会处理。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E2.7 进程的通信\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E为什么需要进程间通信呢？\u003C\u002Fp\u003E\u003Cp\u003E因为进程是\u003Ccode\u003E分配系统资源的单位\u003C\u002Fcode\u003E（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-eecdaca86fd1bc961809e3bfe1aa96f0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"521\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-eecdaca86fd1bc961809e3bfe1aa96f0_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;521&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"521\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-eecdaca86fd1bc961809e3bfe1aa96f0_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-eecdaca86fd1bc961809e3bfe1aa96f0_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E2.7.1 进程通信方法---共享存储\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E因为两个进程的存储空间\u003Ccode\u003E不能相互访问\u003C\u002Fcode\u003E，所以操作系统就提供的一个内存空间让彼此都能访问，这就是共享存储的原理。 \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-3fb36859dcddbe9fdf5804a2736177d5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"590\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-3fb36859dcddbe9fdf5804a2736177d5_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;590&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"590\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-3fb36859dcddbe9fdf5804a2736177d5_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-3fb36859dcddbe9fdf5804a2736177d5_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E其中，介绍一下基于存储区的共享。\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E在内存中画出一块\u003Ccode\u003E共享存储区\u003C\u002Fcode\u003E，数据的形式、存放位置都是由进程控制，而不是操作系统。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E2.7.2 进程通信方法---管道\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-b515e997f54104f37d98884864437162_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1144\" data-rawheight=\"464\" class=\"origin_image zh-lightbox-thumb\" width=\"1144\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-b515e997f54104f37d98884864437162_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1144&#39; height=&#39;464&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1144\" data-rawheight=\"464\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1144\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-b515e997f54104f37d98884864437162_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-b515e997f54104f37d98884864437162_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E管道数据是以\u003Ccode\u003E字符流\u003C\u002Fcode\u003E（注意不是字节流）的形式写入管道，当管道写满时，写进程的\u003Ccode\u003Ewrite()\u003C\u002Fcode\u003E系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的\u003Ccode\u003Eread()\u003C\u002Fcode\u003E系统调用将被阻塞。\u003C\u002Fli\u003E\u003Cli\u003E如果没写满就不允许读。如果都没空就不允许写。\u003C\u002Fli\u003E\u003Cli\u003E数据一旦被读出，就从管道中被丢弃，这就意味着\u003Ccode\u003E读进程\u003C\u002Fcode\u003E最多只能有一个。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E2.7.3 进程通信方法---消息传递\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E进程间的数据交换以\u003Ccode\u003E格式化的消息\u003C\u002Fcode\u003E为单位。进程通过操作系统提供的\u003Ccode\u003E&#34;发送消息\u002F接收消息&#34;\u003C\u002Fcode\u003E两个原语进行数据交换。\u003C\u002Fp\u003E\u003Cp\u003E其中消息是什么意思呢？就好像你发QQ消息，消息头的来源是你，消息体是你发的内容。如下图：\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-0ed1a405ab13451da4076cb743a4f5be_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1210\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb\" width=\"1210\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-0ed1a405ab13451da4076cb743a4f5be_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1210&#39; height=&#39;376&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1210\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1210\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-0ed1a405ab13451da4076cb743a4f5be_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-0ed1a405ab13451da4076cb743a4f5be_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E接下来我们介绍一种\u003Ccode\u003E间接通信\u003C\u002Fcode\u003E的方式（很像中介者模式或者发布订阅模式）, 如下图：中介者是信箱，进程通过它来收发消息。\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-1540e627619e9db02d939d0c416f2b23_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-1540e627619e9db02d939d0c416f2b23_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;438&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-1540e627619e9db02d939d0c416f2b23_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-1540e627619e9db02d939d0c416f2b23_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E2.8 线程\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\u003Cbr\u002F\u003E为什么要引入线程呢？\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E比如你在玩QQ的时候，QQ是一个进程，如果QQ的进程里没有多线程并发，那么QQ进程就只能\u003Ccode\u003E同一时间做一件事情\u003C\u002Fcode\u003E（比如QQ打字聊天）\u003C\u002Fli\u003E\u003Cli\u003E但是我们真实的场景是QQ聊天的同时，还可以发文件，还可以视频聊天，这说明如果QQ\u003Ccode\u003E没有多线程并发能力\u003C\u002Fcode\u003E，QQ能够的实用性就大大降低了。所以我们\u003Ccode\u003E需要线程\u003C\u002Fcode\u003E，也就是\u003Ccode\u003E需要进程拥有能够并发\u003C\u002Fcode\u003E多个事件的能力。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-9941e971732a776152abf542a264a405_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"641\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-9941e971732a776152abf542a264a405_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;641&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"641\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-9941e971732a776152abf542a264a405_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-9941e971732a776152abf542a264a405_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E引入线程后带来的变化 \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-b7ed435aba046bed7ea68e4d7c81de1c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"461\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-b7ed435aba046bed7ea68e4d7c81de1c_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;461&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"461\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-b7ed435aba046bed7ea68e4d7c81de1c_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-b7ed435aba046bed7ea68e4d7c81de1c_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E3 进程的同步和互斥\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E同步。是指多个进程中发生的事件存在某种先后顺序。即某些进程的执行必须先于另一些进程。\u003C\u002Fp\u003E\u003Cp\u003E比如说\u003Ccode\u003E进程A\u003C\u002Fcode\u003E需要从缓冲区读取\u003Ccode\u003E进程B\u003C\u002Fcode\u003E产生的信息，当缓冲区为空时，\u003Ccode\u003E进程B\u003C\u002Fcode\u003E因为读取不到信息而被阻塞。而当\u003Ccode\u003E进程A\u003C\u002Fcode\u003E产生信息放入缓冲区时，\u003Ccode\u003E进程B\u003C\u002Fcode\u003E才会被唤醒。概念如图1所示。 \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-17268cfbbd9d6fc7193729bf56b3c77a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"498\" data-rawheight=\"291\" class=\"origin_image zh-lightbox-thumb\" width=\"498\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-17268cfbbd9d6fc7193729bf56b3c77a_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;498&#39; height=&#39;291&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"498\" data-rawheight=\"291\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"498\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-17268cfbbd9d6fc7193729bf56b3c77a_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-17268cfbbd9d6fc7193729bf56b3c77a_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E互斥。是指多个进程不允许同时使用同一资源。当某个进程使用某种资源的时候，其他进程必须等待。\u003C\u002Fp\u003E\u003Cp\u003E比如\u003Ccode\u003E进程B\u003C\u002Fcode\u003E需要访问打印机，但此时\u003Ccode\u003E进程A\u003C\u002Fcode\u003E占有了打印机，\u003Ccode\u003E进程B\u003C\u002Fcode\u003E会被阻塞，直到\u003Ccode\u003E进程A\u003C\u002Fcode\u003E释放了打印机资源,进程B才可以继续执行。概念如图3所示。 \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-7f6f7e617d5dcd32b4faa9d44d48d5ae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"443\" data-rawheight=\"256\" class=\"origin_image zh-lightbox-thumb\" width=\"443\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-7f6f7e617d5dcd32b4faa9d44d48d5ae_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;443&#39; height=&#39;256&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"443\" data-rawheight=\"256\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"443\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-7f6f7e617d5dcd32b4faa9d44d48d5ae_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-7f6f7e617d5dcd32b4faa9d44d48d5ae_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cbr\u002F\u003E\u003Cb\u003E 3.1 信号量（了解概念即可）\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E信号量\u003C\u002Fcode\u003E主要是来解决进程的\u003Ccode\u003E同步\u003C\u002Fcode\u003E和\u003Ccode\u003E互斥\u003C\u002Fcode\u003E的，我们前端需要了解，如果涉及到同步和互斥的关系（我们编程大多数关于流程的逻辑问题，本质不就是同步和互斥吗？）\u003C\u002Fp\u003E\u003Cp\u003E在操作系统中，常用\u003Ccode\u003EP、V信号量\u003C\u002Fcode\u003E来实现进程间的\u003Ccode\u003E同步\u003C\u002Fcode\u003E和\u003Ccode\u003E互斥\u003C\u002Fcode\u003E，我们简单了解一下一种常用的信号量，\u003Ccode\u003E记录型信号量\u003C\u002Fcode\u003E来简单了解一下信号量本质是怎样的。（c语言来表示，会有备注）\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"cm\"\u003E\u002F*记录型信号量的定义*\u002F\u003C\u002Fspan\u003E\n\u003Cspan class=\"nx\"\u003Etypedef\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Estruct\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"kr\"\u003Eint\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Evalue\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E;\u003C\u002Fspan\u003E \u003Cspan class=\"c1\"\u003E\u002F\u002F 剩余资源\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E    \u003Cspan class=\"nx\"\u003EStruct\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Eprocess\u003C\u002Fspan\u003E \u003Cspan class=\"o\"\u003E*\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003EL\u003C\u002Fspan\u003E \u003Cspan class=\"c1\"\u003E\u002F\u002F 等待队列\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E}\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Esemaphore\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E意思是信号量的结构有两部分组成，\u003Ccode\u003E一部分是剩余资源value\u003C\u002Fcode\u003E，比如目前有两台打印机空闲，那么剩余资源就是2，谁正在使用打印机，剩余资源就减1。\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003EStruct process *L\u003C\u002Fcode\u003E意思是，比如2台打印机都有人在用，这时候你的要用打印机，此时会把这个打印机资源的请求放入阻塞队列，L就是阻塞队列的地址。\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"cm\"\u003E\u002F*P 操作，也就是记录型信号量的请求资源操作*\u002F\u003C\u002Fspan\u003E\n\u003Cspan class=\"k\"\u003Evoid\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Ewait\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Esemaphore\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003ES\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"nx\"\u003ES\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Evalue\u003C\u002Fspan\u003E\u003Cspan class=\"o\"\u003E--\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"k\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003ES\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Evalue\u003C\u002Fspan\u003E \u003Cspan class=\"o\"\u003E&lt;\u003C\u002Fspan\u003E \u003Cspan class=\"mi\"\u003E0\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E){\u003C\u002Fspan\u003E\n        \u003Cspan class=\"nx\"\u003Eblock\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003ES\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003EL\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E);\u003C\u002Fspan\u003E\n    \u003Cspan class=\"p\"\u003E}\u003C\u002Fspan\u003E\n\u003Cspan class=\"p\"\u003E}\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E需要注意的是，如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列中。\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"cm\"\u003E\u002F*V 操作，也就是记录型信号量的释放资源操作*\u002F\u003C\u002Fspan\u003E\n\u003Cspan class=\"k\"\u003Evoid\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Esingal\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Esemaphore\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003ES\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"nx\"\u003ES\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Evalue\u003C\u002Fspan\u003E\u003Cspan class=\"o\"\u003E++\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"k\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003ES\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Evalue\u003C\u002Fspan\u003E \u003Cspan class=\"o\"\u003E&lt;=\u003C\u002Fspan\u003E \u003Cspan class=\"mi\"\u003E0\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E){\u003C\u002Fspan\u003E\n        \u003Cspan class=\"nx\"\u003Ewakeup\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003ES\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003EL\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E);\u003C\u002Fspan\u003E\n    \u003Cspan class=\"p\"\u003E}\u003C\u002Fspan\u003E\n\u003Cspan class=\"p\"\u003E}\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E释放资源后，若还有别的进程在等待这个资源，比如打印机资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为继续态。\u003Cbr\u002F\u003E 3.2 生产者消费者问题（了解概念即可）\u003Cbr\u002F\u003E 为什么要讲这个呢，主要是node的流的机制，本质就是生产者消费者问题，可以简单的看看这个问题如何解决。\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-56f5dcd65a46517aa670d491e4680658_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-56f5dcd65a46517aa670d491e4680658_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;414&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-56f5dcd65a46517aa670d491e4680658_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-56f5dcd65a46517aa670d491e4680658_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E如上图，\u003Ccode\u003E生产者\u003C\u002Fcode\u003E的主要作用是生成\u003Ccode\u003E一定量的数据放到缓冲区中\u003C\u002Fcode\u003E，然后\u003Ccode\u003E重复此过程\u003C\u002Fcode\u003E。与此同时，消费者也在\u003Ccode\u003E缓冲区消耗这些数据\u003C\u002Fcode\u003E。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。\u003C\u002Fp\u003E\u003Cp\u003E这里我们需要两个同步信号量和一个互斥信号量.\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"c1\"\u003E\u002F\u002F 互斥信号量，实现对缓冲区的互斥访问\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Esemaphore\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Emutex\u003C\u002Fspan\u003E \u003Cspan class=\"o\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"mi\"\u003E1\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E;\u003C\u002Fspan\u003E\n\u003Cspan class=\"c1\"\u003E\u002F\u002F 同步信号量，表示目前还可以生产几个产品\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Esemaphore\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Eempty\u003C\u002Fspan\u003E \u003Cspan class=\"o\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003En\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E;\u003C\u002Fspan\u003E\n\u003Cspan class=\"c1\"\u003E\u002F\u002F 同步信号量，表示目前可以消耗几个产品\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Esemaphore\u003C\u002Fspan\u003E \u003Cspan class=\"nx\"\u003Efull\u003C\u002Fspan\u003E \u003Cspan class=\"o\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"mi\"\u003E0\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E生产者代码如下\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"nx\"\u003Eproducer\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E()\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"k\"\u003Ewhile\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"mi\"\u003E1\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E{\u003C\u002Fspan\u003E\n        \u003Cspan class=\"c1\"\u003E\u002F\u002F 生产一个产品\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E        \u003Cspan class=\"nx\"\u003EP\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Eempty\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E);\u003C\u002Fspan\u003E\n        \u003Cspan class=\"c1\"\u003E\u002F\u002F 对缓冲区加锁\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E        \u003Cspan class=\"nx\"\u003EP\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Emutex\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E);\u003C\u002Fspan\u003E\n        \u003Cspan class=\"nx\"\u003E这里的代码是生产一个产品\u003C\u002Fspan\u003E\n        \u003Cspan class=\"c1\"\u003E\u002F\u002F 解锁\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E        \u003Cspan class=\"nx\"\u003EV\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Emutex\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E);\u003C\u002Fspan\u003E\n        \u003Cspan class=\"c1\"\u003E\u002F\u002F 产出一个产品\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E        \u003Cspan class=\"nx\"\u003EV\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Efull\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E);\u003C\u002Fspan\u003E\n    \u003Cspan class=\"p\"\u003E}\u003C\u002Fspan\u003E\n\u003Cspan class=\"p\"\u003E}\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E消费者代码如下\u003C\u002Fp\u003E\u003Cdiv class=\"highlight\"\u003E\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"nx\"\u003Eproducer\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E()\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"k\"\u003Ewhile\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"mi\"\u003E1\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"p\"\u003E{\u003C\u002Fspan\u003E\n        \u003Cspan class=\"c1\"\u003E\u002F\u002F 消费一个产品\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E        \u003Cspan class=\"nx\"\u003EP\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Efull\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E);\u003C\u002Fspan\u003E\n        \u003Cspan class=\"c1\"\u003E\u002F\u002F 对缓冲区加锁\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E        \u003Cspan class=\"nx\"\u003EP\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Emutex\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E);\u003C\u002Fspan\u003E\n        \u003Cspan class=\"nx\"\u003E这里的代码是消费一个产品\u003C\u002Fspan\u003E\n        \u003Cspan class=\"c1\"\u003E\u002F\u002F 解锁\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E        \u003Cspan class=\"nx\"\u003EV\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Emutex\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E);\u003C\u002Fspan\u003E\n        \u003Cspan class=\"c1\"\u003E\u002F\u002F 消费一个产品\n\u003C\u002Fspan\u003E\u003Cspan class=\"c1\"\u003E\u003C\u002Fspan\u003E        \u003Cspan class=\"nx\"\u003EV\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"nx\"\u003Eempty\u003C\u002Fspan\u003E\u003Cspan class=\"p\"\u003E);\u003C\u002Fspan\u003E\n    \u003Cspan class=\"p\"\u003E}\u003C\u002Fspan\u003E\n\u003Cspan class=\"p\"\u003E}\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003Cp\u003E\u003Cb\u003E4 内存的基础知识和概念\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E为什么需要内存?\u003C\u002Fp\u003E\u003Cp\u003E内存是计算机\u003Ccode\u003E其它硬件设备\u003C\u002Fcode\u003E与``CPU沟通`的桥梁、中转站。程序执行前需要先放到内存中才能被CPU处理。\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E4.1 cpu如何区分执行程序的数据在内存的什么地方\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E是通过给\u003Ccode\u003E内存的存储单元编址\u003C\u002Fcode\u003E实现的。（存储单元一般是以字节为单位）\u003C\u002Fli\u003E\u003Cli\u003E如下图，内存的存储单元，就像一个酒店的房间，都有编号，比如程序一的数据都在1楼，1楼1号存储着程序里\u003Ccode\u003Elet a = 1\u003C\u002Fcode\u003E这段代码。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-81676288cdcb44e93ff2fe84f90153e7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"562\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-81676288cdcb44e93ff2fe84f90153e7_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;562&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"562\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-81676288cdcb44e93ff2fe84f90153e7_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-81676288cdcb44e93ff2fe84f90153e7_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E4.2 内存管理-内存空间的分配与回收\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E 内存分配分为\u003Ccode\u003E连续分配\u003C\u002Fcode\u003E和\u003Ccode\u003E非连续分配\u003C\u002Fcode\u003E，连续分配是指用户进程分配的必须是\u003Ccode\u003E一个连续的内存空间\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E 这里我们只讲连续分配中的\u003Ccode\u003E动态分区分配\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E 什么是动态分区分配呢，这种分配方式\u003Ccode\u003E不会预先划分内存分区\u003C\u002Fcode\u003E，而是在进程装入内存时，根据进程的大小\u003Ccode\u003E动态地\u003C\u002Fcode\u003E建立分区，并使分区的大小\u003Ccode\u003E正好适合\u003C\u002Fcode\u003E进程的需要。（比如，某计算机内存大小64MB，系统区8MB，用户区56MB...，现在我们有几个进程要装入内存，如下图）\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-a36af6e683487ea844ef9775b4d46d37_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"987\" data-rawheight=\"606\" class=\"origin_image zh-lightbox-thumb\" width=\"987\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-a36af6e683487ea844ef9775b4d46d37_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;987&#39; height=&#39;606&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"987\" data-rawheight=\"606\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"987\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-a36af6e683487ea844ef9775b4d46d37_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-a36af6e683487ea844ef9775b4d46d37_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E随之而来的问题就是，如果此时进程1使用完了，相应在内存上的数据也被删除了，那么\u003Ccode\u003E空闲的区域\u003C\u002Fcode\u003E，后面该怎么分配（也就是说随着进程退出，会有很多空闲的内存区域出现）\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E我们讲一种较为简单的处理方法叫\u003Ccode\u003E空闲分区表\u003C\u002Fcode\u003E法来解决这个问题。如下图，右侧的表格就是一个空闲分区表。\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-6e75f190869be3631173ccc30f3ba25d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1029\" data-rawheight=\"457\" class=\"origin_image zh-lightbox-thumb\" width=\"1029\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-6e75f190869be3631173ccc30f3ba25d_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1029&#39; height=&#39;457&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1029\" data-rawheight=\"457\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1029\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-6e75f190869be3631173ccc30f3ba25d_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-6e75f190869be3631173ccc30f3ba25d_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配呢，例如下图，分别有\u003Ccode\u003E20MB\u003C\u002Fcode\u003E，\u003Ccode\u003E10MB\u003C\u002Fcode\u003E，\u003Ccode\u003E4MB\u003C\u002Fcode\u003E三个空闲分区块，现在\u003Ccode\u003E进程5\u003C\u002Fcode\u003E需要\u003Ccode\u003E4MB\u003C\u002Fcode\u003E空闲分区，改怎么分配呢？\u003Cbr\u002F\u003E 我们需要按照一定的动态分区分配算法，比如有\u003Ccode\u003E首次适应算法\u003C\u002Fcode\u003E，指的是每次都从低地址开始查找，找到第一个能满足大小的空闲分区。还有比如\u003Ccode\u003E最佳适应算法\u003C\u002Fcode\u003E，指的是从空闲分区表中找到最小的适合分配的分区块来满足需求。\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-3d377f34b6249c48213b1298d403cfdc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"960\" class=\"origin_image zh-lightbox-thumb\" width=\"1050\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-3d377f34b6249c48213b1298d403cfdc_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1050&#39; height=&#39;960&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"960\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1050\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-3d377f34b6249c48213b1298d403cfdc_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-3d377f34b6249c48213b1298d403cfdc_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Ccode\u003E连续分配缺点很明显\u003C\u002Fcode\u003E，大多数情况，需要分配的进程大小，不能跟空闲分区剩下的大小完全一样，这样就产生很多很难利用的\u003Ccode\u003E内存碎片\u003C\u002Fcode\u003E。\u003Cbr\u002F\u003E 这里我们介绍一种更好的空闲分区的分配方法，\u003Ccode\u003E基本分页存储\u003C\u002Fcode\u003E。如下图\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-40344f5f6e75383ad2f4c21725784d4f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"1130\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-40344f5f6e75383ad2f4c21725784d4f_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;960&#39; height=&#39;1130&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"1130\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-40344f5f6e75383ad2f4c21725784d4f_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-40344f5f6e75383ad2f4c21725784d4f_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E将内存空间分为\u003Ccode\u003E一个个大小相等\u003C\u002Fcode\u003E的分区（比如：每个分区\u003Ccode\u003E4KB\u003C\u002Fcode\u003E）.每个分区就是一个\u003Ccode\u003E“页框”\u003C\u002Fcode\u003E。页框号从\u003Ccode\u003E0\u003C\u002Fcode\u003E开始。\u003C\u002Fp\u003E\u003Cp\u003E将用户进程的地址空间分为与页框大小相等的一个个区域，称为\u003Ccode\u003E“页”\u003C\u002Fcode\u003E。每个页也是从\u003Ccode\u003E0\u003C\u002Fcode\u003E开始。\u003C\u002Fp\u003E\u003Cp\u003E进程的页与内存的页框有着一一对应的关系。各个页不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。\u003Cbr\u002F\u003E\u003Cbr\u002F\u003E\u003Cb\u003E5 文件管理\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E文件是什么？\u003C\u002Fp\u003E\u003Cp\u003E文件就是一组有意义的\u003Ccode\u003E信息\u002F数据\u003C\u002Fcode\u003E集合。\u003C\u002Fp\u003E\u003Cp\u003E计算机中存放了各种各样的文件，一个文件有哪些属性呢？文件内部的数据应该怎样组织起来？文件之间又该怎么组织起来？\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E5.1 文件的属性\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-b39d13c1a192136c1ac54a5c1d71052c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1077\" data-rawheight=\"960\" class=\"origin_image zh-lightbox-thumb\" width=\"1077\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-b39d13c1a192136c1ac54a5c1d71052c_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1077&#39; height=&#39;960&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1077\" data-rawheight=\"960\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1077\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-b39d13c1a192136c1ac54a5c1d71052c_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-b39d13c1a192136c1ac54a5c1d71052c_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E文件名。即文件的名字，需要注意的是，同一目录下\u003Ccode\u003E不允许\u003C\u002Fcode\u003E有重名的文件。\u003C\u002Fli\u003E\u003Cli\u003E标识符。操作系统用于区分各个文件的一种\u003Ccode\u003E内部的名称\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E类型。文件的类型。\u003C\u002Fli\u003E\u003Cli\u003E位置。文件\u003Ccode\u003E存放的路径\u003C\u002Fcode\u003E，同时也是在硬盘里的位置（需要转换成物理硬盘上的地址）\u003C\u002Fli\u003E\u003Cli\u003E创建时间、上次修改时间、文件所有者就是字面意思。\u003C\u002Fli\u003E\u003Cli\u003E保护信息。比如对这个文件的\u003Ccode\u003E执行权限\u003C\u002Fcode\u003E，是否有删除文件权限，修改文件权限等等。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E 5.2 文件内部数据如何组织在一起\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E如下图，文件主要分为\u003Ccode\u003E有结构文件\u003C\u002Fcode\u003E和\u003Ccode\u003E无结构文件\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-425ad94c14b2bb1b25219adfe6975199_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"603\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-425ad94c14b2bb1b25219adfe6975199_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;603&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"603\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-425ad94c14b2bb1b25219adfe6975199_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-425ad94c14b2bb1b25219adfe6975199_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E5.3 文件之间如何组织起来\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E通过\u003Ccode\u003E树状结构\u003C\u002Fcode\u003E组织的。例如\u003Ccode\u003Ewindows\u003C\u002Fcode\u003E的文件间的组织关系如下：\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-814cf4f109a766b24aa211becd8f5083_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1170\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb\" width=\"1170\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-814cf4f109a766b24aa211becd8f5083_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1170&#39; height=&#39;266&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1170\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1170\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-814cf4f109a766b24aa211becd8f5083_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-814cf4f109a766b24aa211becd8f5083_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E接下来我们详细的了解一下\u003Ccode\u003E文件的逻辑结构\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E5.4 文件的逻辑结构\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E逻辑结构是指，在用户看来，文件内部的数据是如何组织起来的，而\u003Ccode\u003E“物理结构”\u003C\u002Fcode\u003E是在操作系统看来，文件是如何保存在外存，比如\u003Ccode\u003E硬盘\u003C\u002Fcode\u003E中的。\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-16ca235ec9dd3adb9627ffb5e1aa756b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1061\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb\" width=\"1061\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-16ca235ec9dd3adb9627ffb5e1aa756b_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1061&#39; height=&#39;302&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1061\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1061\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-16ca235ec9dd3adb9627ffb5e1aa756b_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-16ca235ec9dd3adb9627ffb5e1aa756b_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E比如，\u003Ccode\u003E“线性表”\u003C\u002Fcode\u003E就是一种逻辑结构，在用户看来，线性表就是一组有先后关系的元素序列，如：\u003Ccode\u003Ea,b,c,d,e....\u003C\u002Fcode\u003E \u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Ccode\u003E“线性表”\u003C\u002Fcode\u003E这种逻辑结构可以用不同的物理结构实现，比如：\u003Ccode\u003E顺序表\u002F链表\u003C\u002Fcode\u003E。\u003Ccode\u003E顺序表\u003C\u002Fcode\u003E的各个元素在逻辑上相邻，在物理上也相邻：而\u003Ccode\u003E链表\u003C\u002Fcode\u003E的各个元素在物理上可以是不相邻的。\u003C\u002Fli\u003E\u003Cli\u003E因此，顺序表可以实现\u003Ccode\u003E“随机访问”\u003C\u002Fcode\u003E，而\u003Ccode\u003E“链表”\u003C\u002Fcode\u003E无法实现随机访问。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E接下来我了解一下有结构文件的三种逻辑结构\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E5.4.1 顺序文件\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E什么是顺序文件\u003C\u002Fp\u003E\u003Cp\u003E指的是文件中的记录一个接一个地在逻辑上是\u003Ccode\u003E顺序排列\u003C\u002Fcode\u003E，记录可以是\u003Ccode\u003E定长\u003C\u002Fcode\u003E或\u003Ccode\u003E变长\u003C\u002Fcode\u003E，各个记录在物理上可以\u003Ccode\u003E顺序存储\u003C\u002Fcode\u003E或\u003Ccode\u003E链式存储\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-0bae88a10cdc1cae786fc8058e5f6857_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-0bae88a10cdc1cae786fc8058e5f6857_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;173&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-0bae88a10cdc1cae786fc8058e5f6857_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-0bae88a10cdc1cae786fc8058e5f6857_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cbr\u002F\u003E \u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E顺序文件按结构来划分，可以分为\u003Ccode\u003E串结构\u003C\u002Fcode\u003E和\u003Ccode\u003E顺序结构\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E串结构是指记录之间的顺序与\u003Ccode\u003E关键字无关\u003C\u002Fcode\u003E，通常都是按照记录的时间决定记录的顺序。\u003C\u002Fli\u003E\u003Cli\u003E顺序结构就必须保证记录之间的先后顺序按\u003Ccode\u003E关键字排列\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E这里需要注意的知识点是，顺序文件的存储方式和是否\u003Ccode\u003E按关键字排列\u003C\u002Fcode\u003E，会影响数据\u003Ccode\u003E是否支持随机存取\u003C\u002Fcode\u003E和\u003Ccode\u003E是否可以快速按关键字找到对应记录\u003C\u002Fcode\u003E的功能。\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-0c48cacc53fe65a4cdd9f89d6b7c738c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"985\" data-rawheight=\"216\" class=\"origin_image zh-lightbox-thumb\" width=\"985\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-0c48cacc53fe65a4cdd9f89d6b7c738c_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;985&#39; height=&#39;216&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"985\" data-rawheight=\"216\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"985\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-0c48cacc53fe65a4cdd9f89d6b7c738c_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-0c48cacc53fe65a4cdd9f89d6b7c738c_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E5.4.2 索引文件\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E对于\u003Ccode\u003E可变长记录文件\u003C\u002Fcode\u003E，要找到\u003Ccode\u003E第i\u003C\u002Fcode\u003E个记录，必须先顺序查找\u003Ccode\u003E前i-1\u003C\u002Fcode\u003E个记录，但是很多场景中又必须使用可变长记录，如何解决这个问题呢？这就引出来马上讲的\u003Ccode\u003E索引文件\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-fdc7568d2a42acfe295964805fa2b0bb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-fdc7568d2a42acfe295964805fa2b0bb_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;482&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-fdc7568d2a42acfe295964805fa2b0bb_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-fdc7568d2a42acfe295964805fa2b0bb_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E 给这些变长的记录都用一张索引表来记录，一个索引表项包括了\u003Ccode\u003E索引号\u003C\u002Fcode\u003E，\u003Ccode\u003E长度\u003C\u002Fcode\u003E和\u003Ccode\u003E指针\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E 其中，可以将关键字作为索引号的内容，如果关键字本身的排列是有序的，那么还可以按照关键字进行折半查找。\u003C\u002Fli\u003E\u003Cli\u003E 但是建立索引表的问题也很明显，首先若要\u003Ccode\u003E删除\u002F增加\u003C\u002Fcode\u003E一个记录，同时也要对\u003Ccode\u003E索引表\u003C\u002Fcode\u003E操作，其次，如果\u003Ccode\u003E增加一条记录才1KB\u003C\u002Fcode\u003E，但是索引表\u003Ccode\u003E增加i一条记录可能有8KB\u003C\u002Fcode\u003E，以至于索引表的体积大大多于记录。存储空间的利用率就比较低。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E5.4.3 索引顺序文件\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E索引顺序文件是\u003Ccode\u003E索引文件\u003C\u002Fcode\u003E和\u003Ccode\u003E顺序文件\u003C\u002Fcode\u003E思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是，并不是每个记录对应一个\u003Ccode\u003E索引表项\u003C\u002Fcode\u003E，而是一组记录对应一个索引表项。\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-cced46e64a63f8174180146ba93b2aca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"894\" data-rawheight=\"671\" class=\"origin_image zh-lightbox-thumb\" width=\"894\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-cced46e64a63f8174180146ba93b2aca_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;894&#39; height=&#39;671&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"894\" data-rawheight=\"671\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"894\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-cced46e64a63f8174180146ba93b2aca_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-cced46e64a63f8174180146ba93b2aca_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E5.5 文件目录\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E首先，我们需要了解一下\u003Ccode\u003E文件控制\u003C\u002Fcode\u003E块是什么。我们假设目前在\u003Ccode\u003Ewindows的D盘\u003C\u002Fcode\u003E，如下图\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-4e2e285870f324afa71fcda924a90298_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"952\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb\" width=\"952\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-4e2e285870f324afa71fcda924a90298_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;952&#39; height=&#39;349&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"952\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"952\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-4e2e285870f324afa71fcda924a90298_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-4e2e285870f324afa71fcda924a90298_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E可以看到，目录本身就是一种\u003Ccode\u003E有结构的文件\u003C\u002Fcode\u003E，记录了目录里的\u003Ccode\u003E文件\u003C\u002Fcode\u003E和\u003Ccode\u003E目录\u003C\u002Fcode\u003E的信息，比如名称和类型。而这些一条条的记录就是一个个的\u003Ccode\u003E“文件控制块”（FCB）\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\u003Cp\u003E文件目录的结构通常是\u003Ccode\u003E树状的\u003C\u002Fcode\u003E，例如linux里\u003Ccode\u003E\u002F\u003C\u002Fcode\u003E是指根路径，\u003Ccode\u003E\u002Fhome\u003C\u002Fcode\u003E是根路径下的二级目录\u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-61c6d26f7ab9aa935ea434968a97d2d9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"140\" class=\"origin_image zh-lightbox-thumb\" width=\"462\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-61c6d26f7ab9aa935ea434968a97d2d9_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;462&#39; height=&#39;140&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"140\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"462\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-61c6d26f7ab9aa935ea434968a97d2d9_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-61c6d26f7ab9aa935ea434968a97d2d9_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E需要注意的是，树状目录\u003Ccode\u003E不容易实现文件共享\u003C\u002Fcode\u003E，所以在树形目录结构的基础上，增加了一些指向同一节点的有向边（可以简单理解为引用关系，就跟js里的对象一样）\u003C\u002Fli\u003E\u003Cli\u003E也就是说需要为\u003Ccode\u003E每个共享节点\u003C\u002Fcode\u003E设置一个\u003Ccode\u003E共享计数器\u003C\u002Fcode\u003E，用于记录此时有多少个地方在共享该结点。只有\u003Ccode\u003E共享计数器减为0\u003C\u002Fcode\u003E，才删除该节点。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E5.6 文件存储空间管理\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E首先，我们了解一下磁盘分为\u003Ccode\u003E目录区\u003C\u002Fcode\u003E和\u003Ccode\u003E文件区\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-eef6e13eb0594957619479b01c0f019e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"713\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb\" width=\"713\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-eef6e13eb0594957619479b01c0f019e_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;713&#39; height=&#39;545&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"713\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"713\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-eef6e13eb0594957619479b01c0f019e_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-eef6e13eb0594957619479b01c0f019e_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E接着，我们了解一下常见的两种\u003Ccode\u003E文件存储空间的管理算法\u003C\u002Fcode\u003E，如下图，假如硬盘上\u003Ccode\u003E空闲的数据块\u003C\u002Fcode\u003E是蓝色，\u003Ccode\u003E非空闲的数据\u003C\u002Fcode\u003E块是橙色。\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-184c51214e242b01930a749d58d242f6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"367\" data-rawheight=\"460\" class=\"content_image\" width=\"367\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;367&#39; height=&#39;460&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"367\" data-rawheight=\"460\" class=\"content_image lazy\" width=\"367\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-184c51214e242b01930a749d58d242f6_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E对分配连续的存储空间，可以采用\u003Ccode\u003E空闲表法\u003C\u002Fcode\u003E（只讲这种较简单的方法）来\u003Ccode\u003E分配\u003C\u002Fcode\u003E和\u003Ccode\u003E回收\u003C\u002Fcode\u003E磁盘块。对于分配，可以采用首次适应，最佳适应等算法来决定要为文件分配哪个区间。（空闲表表示如下）\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-552726db497f3a256d5b8eb92779c724_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"799\" data-rawheight=\"473\" class=\"origin_image zh-lightbox-thumb\" width=\"799\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-552726db497f3a256d5b8eb92779c724_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;799&#39; height=&#39;473&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"799\" data-rawheight=\"473\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"799\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-552726db497f3a256d5b8eb92779c724_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-552726db497f3a256d5b8eb92779c724_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E\u003Ccode\u003E首次适应\u003C\u002Fcode\u003E是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到\u003Ccode\u003E第一个满足条件\u003C\u002Fcode\u003E的空闲区间。\u003C\u002Fli\u003E\u003Cli\u003E\u003Ccode\u003E最佳适应算法\u003C\u002Fcode\u003E是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到\u003Ccode\u003E满足条件而且空闲块最小的空闲区间\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E如何回收磁盘块呢，主要分为以下4中情况\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E回收区的前后没有相邻空闲区\u003C\u002Fli\u003E\u003Cli\u003E回收区前后都是空闲区\u003C\u002Fli\u003E\u003Cli\u003E回收区前面是空前去\u003C\u002Fli\u003E\u003Cli\u003E回收区后面是空闲区\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E最重要的是要注意表项合并的问题。(比如说回收区前后都有空闲区就将其一起合并为一个空闲区.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cb\u003E5.7 文件共享\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E文件共享分为两种\u003Cbr\u002F\u003E \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-b5c21b67b3598f93f8f32b6897a57740_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"981\" data-rawheight=\"153\" class=\"origin_image zh-lightbox-thumb\" width=\"981\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-b5c21b67b3598f93f8f32b6897a57740_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;981&#39; height=&#39;153&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"981\" data-rawheight=\"153\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"981\" data-original=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-b5c21b67b3598f93f8f32b6897a57740_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-b5c21b67b3598f93f8f32b6897a57740_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E 注意，多个用户\u003Ccode\u003E共享同一个文件\u003C\u002Fcode\u003E，意味着系统只有\u003Ccode\u003E“一份”\u003C\u002Fcode\u003E文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到\u003Ccode\u003E文件的变化\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E 软连接可以理解为\u003Ccode\u003Ewindows\u003C\u002Fcode\u003E里的\u003Ccode\u003E快捷方式\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\u003Cli\u003E 硬链接可以理解为js里的\u003Ccode\u003E引用计数\u003C\u002Fcode\u003E，只有引用为\u003Ccode\u003E0\u003C\u002Fcode\u003E的时候，才会真正删除这个文件。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E5.8 文件保护\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E操作系统需要保护文件的安全，一般有如下3种方式：\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E口令保护。是指为文件设置一个\u003Ccode\u003E“口令”\u003C\u002Fcode\u003E（比如123），用户请求访问该文件时必须提供对应的口令。口令一般放在文件对应的\u003Ccode\u003EFCB或者索引结点\u003C\u002Fcode\u003E上。\u003C\u002Fli\u003E\u003Cli\u003E加密保护。使用某个\u003Ccode\u003E&#34;密码&#34;\u003C\u002Fcode\u003E对文件进行加密，在访问文件时需要提供\u003Ccode\u003E正确的“密码”\u003C\u002Fcode\u003E才能对文件进行正确的解密。\u003C\u002Fli\u003E\u003Cli\u003E访问控制。在每个文件的FCB或者索引节点种增加一个\u003Ccode\u003E访问控制列表\u003C\u002Fcode\u003E，该表中记录了各个用户可以对该文件执行哪些操作。\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp class=\"ztext-empty-paragraph\"\u003E\u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-a7b61237f5eba1205a19290a08c6784a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-a7b61237f5eba1205a19290a08c6784a_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;401&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-a7b61237f5eba1205a19290a08c6784a_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-a7b61237f5eba1205a19290a08c6784a_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E6 I\u002FO设备\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003E什么是I\u002FO设备\u003C\u002Fp\u003E\u003Cp\u003EI\u002FO就是\u003Ccode\u003E输入输出\u003C\u002Fcode\u003E(Input\u002FOutput)的意思，I\u002FO设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。 \u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-26188020b9338b10a756b3dae6544a7f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"492\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-26188020b9338b10a756b3dae6544a7f_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;492&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"492\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-26188020b9338b10a756b3dae6544a7f_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-26188020b9338b10a756b3dae6544a7f_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cb\u003E6.1 I\u002FO设备分类--按使用特性\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E人机交互类设备，这类设备传输数据的速度慢\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp class=\"ztext-empty-paragraph\"\u003E\u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-cc38dc414319ff5bb2650652ee72e94f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"679\" data-rawheight=\"632\" class=\"origin_image zh-lightbox-thumb\" width=\"679\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-cc38dc414319ff5bb2650652ee72e94f_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;679&#39; height=&#39;632&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"679\" data-rawheight=\"632\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"679\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-cc38dc414319ff5bb2650652ee72e94f_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-cc38dc414319ff5bb2650652ee72e94f_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E存储设备，这类设备传输数据的速度较快\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp class=\"ztext-empty-paragraph\"\u003E\u003Cbr\u002F\u003E\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-14521ea1707fe79e07d26cdbcea1bfdc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"561\" class=\"origin_image zh-lightbox-thumb\" width=\"573\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-14521ea1707fe79e07d26cdbcea1bfdc_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;573&#39; height=&#39;561&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"561\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"573\" data-original=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-14521ea1707fe79e07d26cdbcea1bfdc_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-14521ea1707fe79e07d26cdbcea1bfdc_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E网络通信设备，这类设备的传输速度介于人机交互设备和存储设备之间\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E6.2 I\u002FO控制器\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cp\u003ECPU无法直接控制\u003Ccode\u003EI\u002FO设备的机械部件\u003C\u002Fcode\u003E，因此I\u002FO设备还要有一个电子部件作为\u003Ccode\u003ECPU\u003C\u002Fcode\u003E和\u003Ccode\u003EI\u002FO设备\u003C\u002Fcode\u003E机械部件之间的\u003Ccode\u003E“中介”\u003C\u002Fcode\u003E，用于实现CPU对设备的控制。这个电子部件就是\u003Ccode\u003EI\u002FO控制器\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-1cdd195e726a3ba08f48454d2aac78f9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"350\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-1cdd195e726a3ba08f48454d2aac78f9_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;350&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"350\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-1cdd195e726a3ba08f48454d2aac78f9_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpic2.zhimg.com\u002Fv2-1cdd195e726a3ba08f48454d2aac78f9_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cul\u003E\u003Cli\u003E接收和识别CPU发出的指令是指，比如CPU发来读取文件的命令，I\u002FO控制器中会有相应的\u003Ccode\u003E控制寄存器\u003C\u002Fcode\u003E来存放命令和参数\u003C\u002Fli\u003E\u003Cli\u003E向cpu报告设备的状态是指，I\u002FO控制器会有相应的\u003Ccode\u003E状态寄存器\u003C\u002Fcode\u003E，用来记录I\u002FO设备\u003Ccode\u003E是否空闲\u003C\u002Fcode\u003E或者\u003Ccode\u003E忙碌\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\u003Cli\u003E数据交换是指I\u002FO控制器会设置相应的\u003Ccode\u003E数据寄存器\u003C\u002Fcode\u003E。输出时，数据寄存器用于\u003Ccode\u003E暂存CPU发来的数据\u003C\u002Fcode\u003E，之后再由控制器传送给设备。\u003C\u002Fli\u003E\u003Cli\u003E地址识别是指，为了区分设备控制器中的各个寄存器中的各个寄存器，也需要给各个寄存器设置一个特性的\u003Ccode\u003E“地址”\u003C\u002Fcode\u003E。I\u002FO控制器通过CPU提供的“地址”来判断CPU要读写的是哪个寄存器\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cb\u003E6.3 I\u002FO控制方式\u003C\u002Fb\u003E\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E 这里我们指讲一下目前比较先进的方式，通道控制方式。\u003Cbr\u002F\u003E \u003C\u002Fli\u003E\u003Cli\u003E 通道可以理解为一种\u003Ccode\u003E“弱鸡版CPU”\u003C\u002Fcode\u003E。通道可以识别并执行一系列通道指令。 \u003Cbr\u002F\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cfigure data-size=\"normal\"\u003E\u003Cnoscript\u003E\u003Cimg src=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-93df69aabbeddf94abf5784b5075de93_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"563\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-93df69aabbeddf94abf5784b5075de93_r.jpg\"\u002F\u003E\u003C\u002Fnoscript\u003E\u003Cimg src=\"data:image\u002Fsvg+xml;utf8,&lt;svg xmlns=&#39;http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg&#39; width=&#39;1280&#39; height=&#39;563&#39;&gt;&lt;\u002Fsvg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"563\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-93df69aabbeddf94abf5784b5075de93_r.jpg\" data-actualsrc=\"https:\u002F\u002Fpicb.zhimg.com\u002Fv2-93df69aabbeddf94abf5784b5075de93_b.jpg\"\u002F\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E通道最大的优点是极大的\u003Ccode\u003E减少了CPU的干预频率\u003C\u002Fcode\u003E，\u003Ccode\u003EI\u002FO设备\u003C\u002Fcode\u003E完成任务，通道会向CPU发出\u003Ccode\u003E中断\u003C\u002Fcode\u003E，不需要轮询来问I\u002FO设备是否完成CPU下达的任务。\u003C\u002Fp\u003E\u003Cp\u003E本文完结。\u003C\u002Fp\u003E\u003Cp\u003E预告：后面会有数据结构入门知识（常用的数据结构以及在内存的存储形式，并对比其增删改查的时间复杂度）\u003C\u002Fp\u003E\u003Cp\u003E注： 本文绝大多数资料来源于以下的学习视频资料\u003Cbr\u002F\u003E \u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fwww.bilibili.com\u002Fvideo\u002Fav6538245%3Ffrom%3Dsearch%26seid%3D6918809747167691096\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003E操作系统_清华大学（陈渝）\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fwww.bilibili.com\u002Fvideo\u002Fav70156862%3Ffrom%3Dsearch%26seid%3D6918809747167691096\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003E2019 王道考研 操作系统\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fwww.bilibili.com\u002Fvideo\u002Fav51437944%3Ffrom%3Dsearch%26seid%3D6918809747167691096\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003E操作系统（哈工大李治军老师）32讲\u003C\u002Fa\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cblockquote\u003E作者：lio-mengxiang\u003Cbr\u002F\u003E链接：\u003Ca href=\"https:\u002F\u002Flink.zhihu.com\u002F?target=https%3A\u002F\u002Fjuejin.im\u002Fpost\u002F5e52924e51882549274a51e3\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"\u003E\u003Cspan class=\"invisible\"\u003Ehttps:\u002F\u002F\u003C\u002Fspan\u003E\u003Cspan class=\"visible\"\u003Ejuejin.im\u002Fpost\u002F5e52924e\u003C\u002Fspan\u003E\u003Cspan class=\"invisible\"\u003E51882549274a51e3\u003C\u002Fspan\u003E\u003Cspan class=\"ellipsis\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E来源：掘金\u003C\u002Fblockquote\u003E","adminClosedComment":false,"topics":[{"url":"https:\u002F\u002Fwww.zhihu.com\u002Fapi\u002Fv4\u002Ftopics\u002F19590813","type":"topic","id":"19590813","name":"前端入门"},{"url":"https:\u002F\u002Fwww.zhihu.com\u002Fapi\u002Fv4\u002Ftopics\u002F19552330","type":"topic","id":"19552330","name":"程序员"},{"url":"https:\u002F\u002Fwww.zhihu.com\u002Fapi\u002Fv4\u002Ftopics\u002F19550901","type":"topic","id":"19550901","name":"前端开发"}],"voteupCount":2,"voting":0,"column":{"description":"太多小白被不良公众号\u002F机构误导，所以我想让大家自己了解前端，自己去选择要不要转行，自己去甄选机构，当然也存有私心，希望能够把我们不凡学院列入考虑的top1啦，嘿嘿。","canManage":false,"intro":"让大家都知道前端和培训都是怎么一回事。","isFollowing":false,"urlToken":"c_1212785891581743104","id":"c_1212785891581743104","articlesCount":7,"acceptSubmission":true,"title":"前端转行指南","url":"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fc_1212785891581743104","commentPermission":"all","created":1581930689,"updated":1591593147,"imageUrl":"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-850cfe4aadc723609aa303d5e1710859_720w.jpg?source=172ae18b","author":{"isFollowed":false,"avatarUrlTemplate":"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-2f9551216fc17270ec6eeaecad8999d3.jpg?source=172ae18b","uid":"1029071864857051136","userType":"organization","isFollowing":false,"urlToken":"bu-fan-xue-yuan-34","id":"400402bacda73eb00f80f229df780707","description":"不凡学院由国内一线互联网从业者发起，专注为国内互联网输送优质人才，踏踏实实做教育，把教学放在首位，不虚假承诺，不虚假宣传，让学员真正学到知识，以真实的实际项目为核心，保证学员的技术胜任工作！","name":"不凡学院","isAdvertiser":false,"headline":"一家耿直、靠谱的互联网培训机构。bufanui.com","gender":1,"url":"\u002Forg\u002F400402bacda73eb00f80f229df780707","avatarUrl":"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-2f9551216fc17270ec6eeaecad8999d3_l.jpg?source=172ae18b","isOrg":true,"type":"people"},"followers":19,"type":"column"},"commentCount":0,"contributions":[{"id":23658318,"state":"accepted","type":"first_publish","column":{"description":"太多小白被不良公众号\u002F机构误导，所以我想让大家自己了解前端，自己去选择要不要转行，自己去甄选机构，当然也存有私心，希望能够把我们不凡学院列入考虑的top1啦，嘿嘿。","canManage":false,"intro":"让大家都知道前端和培训都是怎么一回事。","isFollowing":false,"urlToken":"c_1212785891581743104","id":"c_1212785891581743104","articlesCount":7,"acceptSubmission":true,"title":"前端转行指南","url":"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fc_1212785891581743104","commentPermission":"all","created":1581930689,"updated":1591593147,"imageUrl":"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-850cfe4aadc723609aa303d5e1710859_720w.jpg?source=172ae18b","author":{"isFollowed":false,"avatarUrlTemplate":"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-2f9551216fc17270ec6eeaecad8999d3.jpg?source=172ae18b","uid":"1029071864857051136","userType":"organization","isFollowing":false,"urlToken":"bu-fan-xue-yuan-34","id":"400402bacda73eb00f80f229df780707","description":"不凡学院由国内一线互联网从业者发起，专注为国内互联网输送优质人才，踏踏实实做教育，把教学放在首位，不虚假承诺，不虚假宣传，让学员真正学到知识，以真实的实际项目为核心，保证学员的技术胜任工作！","name":"不凡学院","isAdvertiser":false,"headline":"一家耿直、靠谱的互联网培训机构。bufanui.com","gender":1,"url":"\u002Forg\u002F400402bacda73eb00f80f229df780707","avatarUrl":"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-2f9551216fc17270ec6eeaecad8999d3_l.jpg?source=172ae18b","isOrg":true,"type":"people"},"followers":19,"type":"column"}}],"isTitleImageFullScreen":false,"upvotedFollowees":[],"commercialInfo":{"isCommercial":false,"plugin":{}},"suggestEdit":{"status":false,"reason":"","tip":"","url":"","title":""},"reason":"","annotationAction":[],"canTip":false,"tipjarorsCount":0,"isLabeled":false,"hasPublishingDraft":false,"isFavorited":false,"isNormal":true,"status":0,"shareText":"😀前端入门操作系统知识，这一篇就够啦！ - 来自知乎专栏「前端转行指南」，作者: 不凡学院 https:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F130905785 （想看更多？下载 @知乎 App：http:\u002F\u002Fweibo.com\u002Fp\u002F100404711598 ）","canComment":{"status":true,"reason":""},"mcnFpShow":-1,"isVisible":true,"isLiked":false,"likedCount":0,"visibleOnlyToAuthor":false,"hasColumn":true,"republishers":[]}},"columns":{"c_1212785891581743104":{"description":"太多小白被不良公众号\u002F机构误导，所以我想让大家自己了解前端，自己去选择要不要转行，自己去甄选机构，当然也存有私心，希望能够把我们不凡学院列入考虑的top1啦，嘿嘿。","canManage":false,"intro":"让大家都知道前端和培训都是怎么一回事。","isFollowing":false,"urlToken":"c_1212785891581743104","id":"c_1212785891581743104","articlesCount":7,"acceptSubmission":true,"title":"前端转行指南","url":"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fc_1212785891581743104","commentPermission":"all","created":1581930689,"updated":1591593147,"imageUrl":"https:\u002F\u002Fpic3.zhimg.com\u002Fv2-850cfe4aadc723609aa303d5e1710859_720w.jpg?source=172ae18b","author":{"isFollowed":false,"avatarUrlTemplate":"https:\u002F\u002Fpic4.zhimg.com\u002Fv2-2f9551216fc17270ec6eeaecad8999d3.jpg?source=172ae18b","uid":"1029071864857051136","userType":"organization","isFollowing":false,"urlToken":"bu-fan-xue-yuan-34","id":"400402bacda73eb00f80f229df780707","description":"不凡学院由国内一线互联网从业者发起，专注为国内互联网输送优质人才，踏踏实实做教育，把教学放在首位，不虚假承诺，不虚假宣传，让学员真正学到知识，以真实的实际项目为核心，保证学员的技术胜任工作！","name":"不凡学院","isAdvertiser":false,"headline":"一家耿直、靠谱的互联网培训机构。bufanui.com","gender":1,"url":"\u002Forg\u002F400402bacda73eb00f80f229df780707","avatarUrl":"https:\u002F\u002Fpic1.zhimg.com\u002Fv2-2f9551216fc17270ec6eeaecad8999d3_l.jpg?source=172ae18b","isOrg":true,"type":"people"},"followers":19,"type":"column"}},"topics":{},"roundtables":{},"favlists":{},"comments":{},"notifications":{},"ebooks":{},"activities":{},"feeds":{},"pins":{},"promotions":{},"drafts":{},"chats":{},"posts":{},"clubs":{},"clubTags":{}},"currentUser":"967865b912bde7a071705f71793cf75a","account":{"lockLevel":{},"unlockTicketStatus":false,"unlockTicket":null,"challenge":[],"errorStatus":false,"message":"","isFetching":false,"accountInfo":{},"urlToken":{"loading":false}},"settings":{"socialBind":null,"inboxMsg":null,"notification":{},"email":{},"privacyFlag":null,"blockedUsers":{"isFetching":false,"paging":{"pageNo":1,"pageSize":6},"data":[]},"blockedFollowees":{"isFetching":false,"paging":{"pageNo":1,"pageSize":6},"data":[]},"ignoredTopics":{"isFetching":false,"paging":{"pageNo":1,"pageSize":6},"data":[]},"restrictedTopics":null,"laboratory":{}},"notification":{},"people":{"profileStatus":{},"activitiesByUser":{},"answersByUser":{},"answersSortByVotesByUser":{},"answersIncludedByUser":{},"votedAnswersByUser":{},"thankedAnswersByUser":{},"voteAnswersByUser":{},"thankAnswersByUser":{},"topicAnswersByUser":{},"zvideosByUser":{},"articlesByUser":{},"articlesSortByVotesByUser":{},"articlesIncludedByUser":{},"pinsByUser":{},"questionsByUser":{},"commercialQuestionsByUser":{},"favlistsByUser":{},"followingByUser":{},"followersByUser":{},"mutualsByUser":{},"followingColumnsByUser":{},"followingQuestionsByUser":{},"followingFavlistsByUser":{},"followingTopicsByUser":{},"publicationsByUser":{},"columnsByUser":{},"allFavlistsByUser":{},"brands":null,"creationsByUser":{},"creationsSortByVotesByUser":{},"creationsFeed":{},"infinity":{}},"env":{"ab":{"config":{"experiments":[{"expId":"launch-li_general_ebook-9","expPrefix":"li_general_ebook","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-li_new_style-1","expPrefix":"li_new_style","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-qa_cl_guest-2","expPrefix":"qa_cl_guest","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-qa_repost-2","expPrefix":"qa_repost","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-rec_slt_training-2","expPrefix":"rec_slt_training","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-re_unfriend_comm-2","expPrefix":"re_unfriend_comm","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-se_entity22-4","expPrefix":"se_entity22","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-se_whitelist-2","expPrefix":"se_whitelist","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-top_hotlist_ui-3","expPrefix":"top_hotlist_ui","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-tp_discovery-10","expPrefix":"tp_discovery","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-tp_zrec-8","expPrefix":"tp_zrec","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-us_adjust_new-11","expPrefix":"us_adjust_new","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-us_foltopic_user-10","expPrefix":"us_foltopic_user","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-us_noti_count-8","expPrefix":"us_noti_count","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-vd_bullet_second-2","expPrefix":"vd_bullet_second","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-vd_profile_video-11","expPrefix":"vd_profile_video","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-vd_sharpness-3","expPrefix":"vd_sharpness","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-vd_timeguide-2","expPrefix":"vd_timeguide","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-vd_video_replay-3","expPrefix":"vd_video_replay","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"launch-vd_zvideo_link-10","expPrefix":"vd_zvideo_link","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"se_cbert_comp-6","expPrefix":"se_cbert_comp","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"se_v059-4","expPrefix":"se_v059","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"se_major_v3-2","expPrefix":"se_major_v3","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"qa_cdzixun-4","expPrefix":"qa_cdzixun","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"vd_bullet_gui-3","expPrefix":"vd_bullet_gui","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"li_cartopic_meta-10","expPrefix":"li_cartopic_meta","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"li_tp_paidanswer-9","expPrefix":"li_tp_paidanswer","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"li_video_section-5","expPrefix":"li_video_section","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"vd_rec_test-13","expPrefix":"vd_rec_test","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"qa_labeltype-3","expPrefix":"qa_labeltype","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"se_opm-10","expPrefix":"se_opm","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"se_topicfeed-3","expPrefix":"se_topicfeed","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"se_recommend-3","expPrefix":"se_recommend","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"se_auth_src2-3","expPrefix":"se_auth_src2","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"tp_fenqu_wei-2","expPrefix":"tp_fenqu_wei","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"tp_content-4","expPrefix":"tp_content","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"gw_qrlogin-2","expPrefix":"gw_qrlogin","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"rec_expslotpaid-10","expPrefix":"rec_expslotpaid","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"rec_tra_first-6","expPrefix":"rec_tra_first","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false},{"expId":"rec_slotpaidexp-5","expPrefix":"rec_slotpaidexp","isDynamicallyUpdated":true,"isRuntime":false,"includeTriggerInfo":false}],"params":[{"id":"se_hi_trunc","type":"String","value":"0","chainId":"_all_","layerId":"sese_layer_606"},{"id":"tp_dingyue_video","type":"String","value":"0","chainId":"_all_","layerId":"tptp_layer_4"},{"id":"tsp_hotlist_ui","type":"String","value":"3","chainId":"_all_","layerId":"tsptop_layer_1"},{"id":"gue_v_serial","type":"String","value":"1","layerId":"guevd_layer_695"},{"id":"li_panswer_topic","type":"String","value":"0","chainId":"_all_","layerId":"lili_layer_602"},{"id":"gue_share_icon","type":"String","value":"0","layerId":"gueqa_layer_647"},{"id":"ug_follow_topic_1","type":"String","value":"2","chainId":"_all_","layerId":"ugus_layer_3"},{"id":"gue_fo_recom","type":"String","value":"0","layerId":"gueqa_layer_780"},{"id":"ge_vip_cont","type":"String","value":"0","chainId":"_gene_","layerId":"gese_layer_742","key":2828},{"id":"se_club_ui","type":"String","value":"0","chainId":"_all_","layerId":"sese_layer_581"},{"id":"se_merge","type":"String","value":"0","chainId":"_all_","layerId":"sese_layer_713"},{"id":"tp_fenqu_wei","type":"String","value":"1","chainId":"_all_","layerId":"tptp_layer_626"},{"id":"top_test_4_liguangyi","type":"String","value":"1","chainId":"_all_","layerId":"iosus_layer_1"},{"id":"li_car_meta","type":"String","value":"1","chainId":"_all_","layerId":"lili_layer_0"},{"id":"li_sp_mqbk","type":"String","value":"0","chainId":"_all_","layerId":"lili_layer_580"},{"id":"ge_v_v010","type":"String","value":"0","chainId":"_gene_","layerId":"gese_layer_838","key":2787},{"id":"li_viptab_name","type":"String","value":"0","chainId":"_all_","layerId":"lili_layer_0"},{"id":"zr_intervene","type":"String","value":"0","chainId":"_all_","layerId":"zrrec_layer_2"},{"id":"tp_m_intro_re_topic","type":"String","value":"1","chainId":"_all_","layerId":"tptp_layer_2"},{"id":"se_ffzx_jushen1","type":"String","value":"0","chainId":"_all_","layerId":"sese_layer_4"},{"id":"tp_topic_tab","type":"String","value":"0","chainId":"_all_","layerId":"tptp_layer_1"},{"id":"ge_club_pin","type":"String","value":"0","chainId":"_gene_","layerId":"getp_layer_827","key":2775},{"id":"tp_flow_ctr","type":"String","value":"1","chainId":"_all_","layerId":"tptp_layer_619"},{"id":"ge_cbert","type":"String","value":"2","chainId":"_gene_","layerId":"gese_layer_834","key":2715},{"id":"se_usercard","type":"String","value":"0","chainId":"_all_","layerId":"sese_layer_581"},{"id":"pf_adjust","type":"String","value":"1","chainId":"_all_","layerId":"pfus_layer_9"},{"id":"li_ebook_gen_search","type":"String","value":"2","chainId":"_all_","layerId":"lili_layer_10"},{"id":"top_v_album","type":"String","value":"1","chainId":"_all_","layerId":"toptop_layer_0"},{"id":"se_recommend","type":"String","value":"1","chainId":"_all_","layerId":"sese_layer_623"},{"id":"top_quality","type":"String","value":"0","chainId":"_all_","layerId":"toptop_layer_0"},{"id":"gue_video_replay","type":"String","value":"2","layerId":"guevd_layer_3"},{"id":"ge_video","type":"String","value":"0","chainId":"_gene_","layerId":"geli_layer_856","key":2831},{"id":"gue_q_intercept","type":"String","value":"0","layerId":"gueqa_layer_2"},{"id":"ge_infinity6","type":"String","value":"0","chainId":"_gene_","layerId":"gese_layer_742","key":2817},{"id":"tp_header_style","type":"String","value":"1","chainId":"_all_","layerId":"tptp_layer_2"},{"id":"web_sem_ab","type":"String","value":"1","layerId":"webgw_layer_3"},{"id":"web_unfriendly_comm","type":"String","value":"1","layerId":"webre_layer_1"},{"id":"gue_card_test","type":"String","value":"1","layerId":"gueqa_layer_2"},{"id":"zr_rec_answer_cp","type":"String","value":"open","chainId":"_all_","layerId":"zrrec_layer_2"},{"id":"ge_ge02","type":"String","value":"6","chainId":"_gene_","layerId":"gese_layer_742","key":2599},{"id":"se_topicfeed","type":"String","value":"1","chainId":"_all_","layerId":"sese_layer_12"},{"id":"se_return_1","type":"String","value":"0","chainId":"_all_","layerId":"sese_layer_624"},{"id":"li_vip_verti_search","type":"String","value":"0","chainId":"_all_","layerId":"lili_layer_2"},{"id":"gue_self_censoring","type":"String","value":"1","layerId":"gueqa_layer_1"},{"id":"web_audit_01","type":"String","value":"case1","layerId":"webre_layer_1"},{"id":"ge_relation2","type":"String","value":"0","chainId":"_gene_","layerId":"gese_layer_858","key":2796},{"id":"pf_noti_entry_num","type":"String","value":"2","chainId":"_all_","layerId":"pfus_layer_718"},{"id":"gue_push2follow","type":"String","value":"1","layerId":"gueqa_layer_3"},{"id":"zr_training_boost","type":"String","value":"false","chainId":"_all_","layerId":"zrrec_layer_10"},{"id":"web_pcleft","type":"String","value":"0","layerId":"webtop_layer_701"},{"id":"ge_newyanzhi","type":"String","value":"0","chainId":"_gene_","layerId":"geus_layer_839","key":2788},{"id":"gue_q_share","type":"String","value":"0","layerId":"gueqa_layer_647"},{"id":"ge_tab","type":"String","value":"1","chainId":"_gene_","layerId":"gese_layer_742","key":2716},{"id":"se_col_boost","type":"String","value":"1","chainId":"_all_","layerId":"sese_layer_11"},{"id":"se_whitelist","type":"String","value":"1","chainId":"_all_","layerId":"sese_layer_2"},{"id":"tp_topic_style","type":"String","value":"0","chainId":"_all_","layerId":"tptp_layer_4"},{"id":"ug_newtag","type":"String","value":"1","chainId":"_all_","layerId":"ugus_layer_4"},{"id":"li_pl_xj","type":"String","value":"0","chainId":"_all_","layerId":"lili_layer_580"},{"id":"gue_repost1","type":"String","value":"1","layerId":"guere_layer_819"},{"id":"pf_profile2_tab","type":"String","value":"0","chainId":"_all_","layerId":"pfus_layer_601"},{"id":"gue_visit_n_artcard","type":"String","value":"1","layerId":"gueqa_layer_579"},{"id":"tp_zrec","type":"String","value":"1","chainId":"_all_","layerId":"tptp_layer_619"},{"id":"zr_slotpaidexp","type":"String","value":"8","chainId":"_all_","layerId":"zrrec_layer_5"},{"id":"ge_ge01","type":"String","value":"5","chainId":"_gene_","layerId":"gese_layer_742","key":2597},{"id":"ge_qngz1","type":"String","value":"0","chainId":"_gene_","layerId":"getp_layer_827","key":2797},{"id":"tp_discover","type":"String","value":"1","chainId":"_all_","layerId":"tptp_layer_3"},{"id":"tp_topic_tab_new","type":"String","value":"0-0-0","chainId":"_all_","layerId":"tptp_layer_3"},{"id":"top_ebook","type":"String","value":"0","chainId":"_all_","layerId":"toptop_layer_1"},{"id":"li_answer_card","type":"String","value":"0","chainId":"_all_","layerId":"lili_layer_3"},{"id":"li_yxzl_new_style_a","type":"String","value":"1","chainId":"_all_","layerId":"lili_layer_607"},{"id":"web_answer_list_ad","type":"String","value":"1","layerId":"webqa_layer_4"},{"id":"zr_sim3","type":"String","value":"0","chainId":"_all_","layerId":"zrrec_layer_756"},{"id":"web_ad_banner","type":"String","value":"0","layerId":"webgw_layer_3"},{"id":"se_searchwiki","type":"String","value":"0","chainId":"_all_","layerId":"sese_layer_599"},{"id":"gue_art2qa","type":"String","value":"0","layerId":"gueqa_layer_579"},{"id":"se_colorfultab","type":"String","value":"1","chainId":"_all_","layerId":"sese_layer_2"},{"id":"ge_rm_d2q","type":"String","value":"0","chainId":"_gene_","layerId":"gese_layer_859","key":2834},{"id":"se_sug_term","type":"String","value":"0","chainId":"_all_","layerId":"sese_layer_9"},{"id":"tp_contents","type":"String","value":"1","chainId":"_all_","layerId":"tptp_layer_627"},{"id":"web_login","type":"String","value":"1","layerId":"webgw_layer_759"},{"id":"web_collection_guest","type":"String","value":"1","layerId":"webqa_layer_4"},{"id":"zr_topic_rpc","type":"String","value":"0","chainId":"_all_","layerId":"zrrec_layer_13"},{"id":"se_guess","type":"String","value":"0","chainId":"_all_","layerId":"sese_layer_623"},{"id":"web_creator_route","type":"String","value":"1","layerId":"webtop_layer_1"},{"id":"gue_goods_card","type":"String","value":"0","layerId":"gueqa_layer_1"},{"id":"gue_art_sani","type":"String","value":"0","layerId":"gueqa_layer_647"},{"id":"ge_major_v3","type":"String","value":"0","chainId":"_gene_","layerId":"gese_layer_859","key":2832},{"id":"se_entity22","type":"String","value":"1","chainId":"_all_","layerId":"sese_layer_26"},{"id":"pf_fuceng","type":"String","value":"1","chainId":"_all_","layerId":"pfus_layer_2"},{"id":"zr_km_answer","type":"String","value":"open_cvr","chainId":"_all_","layerId":"zrrec_layer_1"},{"id":"ge_usercard1","type":"String","value":"0","chainId":"_gene_","layerId":"gese_layer_742","key":2740},{"id":"pf_newguide_vertical","type":"String","value":"0","chainId":"_all_","layerId":"pfus_layer_4"},{"id":"gue_vid_tab","type":"String","value":"0","layerId":"guevd_layer_810"},{"id":"gue_repost","type":"String","value":"1","layerId":"gueqa_layer_671"},{"id":"zr_training_first","type":"String","value":"false","chainId":"_all_","layerId":"zrrec_layer_4"},{"id":"qap_question_author","type":"String","value":"0","chainId":"_all_","layerId":"qapqa_layer_2"},{"id":"web_column_auto_invite","type":"String","value":"0","layerId":"webqa_layer_1"},{"id":"zr_search_paid","type":"String","value":"1","chainId":"_all_","layerId":"zrrec_layer_10"},{"id":"li_edu_page","type":"String","value":"old","chainId":"_all_","layerId":"lili_layer_580"},{"id":"gue_recmess","type":"String","value":"0","layerId":"gueqa_layer_795"},{"id":"top_root","type":"String","value":"0","chainId":"_all_","layerId":"toptop_layer_1"},{"id":"top_universalebook","type":"String","value":"1","chainId":"_all_","layerId":"toptop_layer_13"},{"id":"gue_bullet_guide","type":"String","value":"没弹幕？你是第一个","layerId":"guevd_layer_0"},{"id":"gue_zvideo_link","type":"String","value":"1","layerId":"guevd_layer_2"},{"id":"gue_zvideo_title","type":"String","value":"0","layerId":"guevd_layer_559"},{"id":"ls_recommend_test","type":"String","value":"5","chainId":"_all_","layerId":"lsvd_layer_1"},{"id":"web_answerlist_ad","type":"String","value":"0","layerId":"webqa_layer_1"},{"id":"zw_sameq_sorce","type":"String","value":"999","chainId":"_all_","layerId":"zwqa_layer_2"},{"id":"zr_slot_training","type":"String","value":"2","chainId":"_all_","layerId":"zrrec_layer_1"},{"id":"zr_expslotpaid","type":"String","value":"10","chainId":"_all_","layerId":"zrrec_layer_11"},{"id":"tp_clubhyb","type":"String","value":"0","chainId":"_all_","layerId":"tptp_layer_619"},{"id":"pf_creator_card","type":"String","value":"1","chainId":"_all_","layerId":"pfus_layer_1"},{"id":"gue_bullet_second","type":"String","value":"1","layerId":"guevd_layer_1"},{"id":"li_svip_cardshow","type":"String","value":"1","chainId":"_all_","layerId":"lili_layer_0"},{"id":"li_catalog_card","type":"String","value":"1","chainId":"_all_","layerId":"lili_layer_11"},{"id":"qap_labeltype","type":"String","value":"2","chainId":"_all_","layerId":"qapqa_layer_1"},{"id":"ge_v059","type":"String","value":"2","chainId":"_gene_","layerId":"gese_layer_858","key":2791},{"id":"se_college","type":"String","value":"default","chainId":"_all_","layerId":"sese_layer_2"},{"id":"web_enforce_qr","type":"String","value":"0","layerId":"webgw_layer_1"},{"id":"li_svip_tab_search","type":"String","value":"1","chainId":"_all_","layerId":"lili_layer_1"},{"id":"ls_video_commercial","type":"String","value":"0","chainId":"_all_","layerId":"lsvd_layer_7"},{"id":"li_paid_answer_exp","type":"String","value":"0","chainId":"_all_","layerId":"lili_layer_3"},{"id":"tp_sft","type":"String","value":"a","chainId":"_all_","layerId":"tptp_layer_1"},{"id":"ge_social_v2","type":"String","value":"0","chainId":"_gene_","layerId":"gese_layer_815","key":2795},{"id":"se_adsrank","type":"String","value":"4","chainId":"_all_","layerId":"sese_layer_39"},{"id":"gue_sharp","type":"String","value":"1","layerId":"guevd_layer_686"},{"id":"se_auth_src2","type":"String","value":"0","chainId":"_all_","layerId":"sese_layer_713"},{"id":"gue_profile_video","type":"String","value":"1","layerId":"guevd_layer_5"},{"id":"soc_notification","type":"String","value":"1","chainId":"_all_","layerId":"socus_layer_4"},{"id":"pf_foltopic_usernum","type":"String","value":"50","chainId":"_all_","layerId":"pfus_layer_5"},{"id":"web_table","type":"String","value":"0","layerId":"webqa_layer_862"},{"id":"se_auth_src","type":"String","value":"0","chainId":"_all_","layerId":"sese_layer_713"},{"id":"qap_question_visitor","type":"String","value":" 0","chainId":"_all_","layerId":"qapqa_layer_2"},{"id":"ge_v060","type":"String","value":"0","chainId":"_gene_","layerId":"gese_layer_858","key":2782},{"id":"web_heifetz_grow_ad","type":"String","value":"1","layerId":"webgw_layer_3"},{"id":"li_topics_search","type":"String","value":"0","chainId":"_all_","layerId":"lili_layer_0"},{"id":"gue_article_sicon","type":"String","value":"0","layerId":"gueqa_layer_647"},{"id":"tp_meta_card","type":"String","value":"0","chainId":"_all_","layerId":"tptp_layer_1"},{"id":"gue_video_guide","type":"String","value":"1","layerId":"guevd_layer_625"},{"id":"gue_bulletmb","type":"String","value":"0","layerId":"guevd_layer_812"},{"id":"li_video_section","type":"String","value":"1","chainId":"_all_","layerId":"lili_layer_7"},{"id":"gue_cdzixun","type":"String","value":"3","layerId":"gueqa_layer_3"}],"chains":[{"chainId":"_all_"}],"encodedParams":"CiQMC+MK1wqbCg8LAQsnCuwK5AqcCiUK7QoSCxALtArnCusK3goSEgAAAAIAAAYAAAEFAAAAAAIAAA=="},"triggers":{}},"userAgent":{"Edge":false,"Wechat":false,"Weibo":false,"QQ":false,"MQQBrowser":false,"Qzone":false,"Mobile":false,"Android":false,"iOS":false,"isAppleDevice":false,"Zhihu":false,"ZhihuHybrid":false,"isBot":false,"Tablet":false,"UC":false,"Sogou":false,"Qihoo":false,"Baidu":false,"BaiduApp":false,"Safari":false,"GoogleBot":false,"AndroidDaily":false,"iOSDaily":false,"WxMiniProgram":false,"BaiduMiniProgram":false,"QQMiniProgram":false,"JDMiniProgram":false,"isWebView":false,"isMiniProgram":false,"origin":"Mozilla\u002F5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\u002F537.36 (KHTML, like Gecko) Chrome\u002F84.0.4147.125 Safari\u002F537.36"},"appViewConfig":{},"ctx":{"path":"\u002Fp\u002F130905785","query":{},"href":"http:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F130905785","host":"zhuanlan.zhihu.com"},"trafficSource":"production","edition":{"beijing":false,"baidu":false,"sogou":false,"baiduBeijing":false,"sogouBeijing":false,"sogouInput":false,"baiduSearch":false,"googleSearch":false,"miniProgram":false,"xiaomi":false},"theme":"light","enableShortcut":true,"referer":"https:\u002F\u002Fwww.zhihu.com\u002Fsearch?type=content&q=%E5%89%8D%E7%AB%AF%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F","conf":{},"xTrafficFreeOrigin":"","ipInfo":{"cityName":"广州","countryName":"中国","regionName":"广东","countryCode":"CN"},"logged":true},"me":{"columnContributions":[]},"label":{"recognizerLists":{}},"ecommerce":{},"comments":{"pagination":{},"collapsed":{},"reverse":{},"reviewing":{},"conversation":{},"parent":{}},"commentsV2":{"stickers":[],"commentWithPicPermission":{},"notificationsComments":{},"pagination":{},"collapsed":{},"reverse":{},"reviewing":{},"conversation":{},"conversationMore":{},"parent":{}},"pushNotifications":{"default":{"isFetching":false,"isDrained":false,"ids":[]},"follow":{"isFetching":false,"isDrained":false,"ids":[]},"vote_thank":{"isFetching":false,"isDrained":false,"ids":[]},"currentTab":"default","notificationsCount":{"default":0,"follow":0,"vote_thank":0}},"messages":{"data":{},"currentTab":"common","messageCount":0},"register":{"registerValidateSucceeded":null,"registerValidateErrors":{},"registerConfirmError":null,"sendDigitsError":null,"registerConfirmSucceeded":null},"login":{"loginUnregisteredError":false,"loginBindWechatError":false,"loginConfirmError":null,"sendDigitsError":null,"needSMSIdentify":false,"validateDigitsError":false,"loginConfirmSucceeded":null,"qrcodeLoginToken":"","qrcodeLoginScanStatus":0,"qrcodeLoginError":null,"qrcodeLoginReturnNewToken":false},"active":{"sendDigitsError":null,"activeConfirmSucceeded":null,"activeConfirmError":null},"switches":{},"captcha":{"captchaNeeded":false,"captchaValidated":false,"captchaBase64String":null,"captchaValidationMessage":null,"loginCaptchaExpires":false},"sms":{"supportedCountries":[]},"chat":{"chats":{},"inbox":{"recents":{"isFetching":false,"isDrained":false,"isPrevDrained":false,"result":[],"next":null,"key":null},"strangers":{"isFetching":false,"isDrained":false,"isPrevDrained":false,"result":[],"next":null,"key":null},"friends":{"isFetching":false,"isDrained":false,"isPrevDrained":false,"result":[],"next":null,"key":null},"search":{"isFetching":false,"isDrained":false,"isPrevDrained":false,"result":[],"next":null,"key":null},"config":{"newCount":0,"strangerMessageSwitch":false,"strangerMessageUnread":false,"friendCount":0}},"global":{"isChatMqttExisted":false}},"emoticons":{"emoticonGroupList":[],"emoticonGroupDetail":{}},"creator":{"currentCreatorUrlToken":null,"homeData":{"recommendQuestions":[]},"tools":{"question":{"invitationCount":{"questionFolloweeCount":0,"questionTotalCount":0},"goodatTopics":[]},"customPromotion":{"itemLists":{}},"recommend":{"recommendTimes":{}}},"explore":{"academy":{"tabs":[],"article":{}}},"rights":[],"rightsStatus":{},"levelUpperLimit":10,"account":{"growthLevel":{}},"mcn":{},"applyStatus":{}},"recommendation":{"homeRecommendations":[]},"shareTexts":{},"articles":{"voters":{}},"previewPost":{},"favlists":{"relations":{}},"columns":{"voters":{}},"reward":{"answer":{},"article":{},"question":{}},"video":{"data":{},"shareVideoDetail":{},"last":{}},"topstory":{"recommend":{"isFetching":false,"isDrained":false,"afterId":0,"items":[],"next":null},"follow":{"isFetching":false,"isDrained":false,"afterId":0,"items":[],"next":null},"followWonderful":{"isFetching":false,"isDrained":false,"afterId":0,"items":[],"next":null},"sidebar":null,"announcement":{},"hotListCategories":[],"hotList":[],"guestFeeds":{"isFetching":false,"isDrained":false,"afterId":0,"items":[],"next":null},"followExtra":{"isNewUser":null,"isFetched":false,"followCount":0,"followers":[]}},"readStatus":{},"column":{},"requestColumn":{"categories":[],"error":null},"articleContribution":{"contributeRequests":[],"deleteContributeIdList":[],"handledContributeIdList":[],"recommendedColumns":[],"pinnedColumns":[],"sentContributeRequestsIdList":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"c_1212785891581743104"]},"columnContribution":{"contributeRequests":[],"autoInviteEnabled":false,"recommendedContributors":[],"contributionInvitation":null},"draftHistory":{"history":{},"drafts":{}},"upload":{},"articleDraft":{"titleImage":"","titleImageSize":{},"isTitleImageFullScreen":false,"canTitleImageFullScreen":false,"title":"","titleImageUploading":false,"error":"","content":"","draftLoading":false,"updating":false,"globalLoading":false,"pendingVideo":{"resource":null,"error":null},"deleteFail":{"fail":false},"recommendTopics":[],"selectedColumn":0,"articleDisclaimers":[]},"articleDrafts":{"isDrained":false,"isLoading":false,"items":[]},"columnAutocomplete":{"users":[],"friends":[]},"columnCollection":{},"userProfit":{"permission":{"permissionStatus":{"zhiZixuan":0,"recommend":0,"task":0,"plugin":0},"visible":false}},"mcn":{"bindInfo":{},"memberCategoryList":[],"producerList":[],"categoryList":[],"lists":{}},"zvideos":{"campaigns":{},"tagoreCategory":[],"recommendations":{},"insertable":{},"recruit":{"form":{"platform":"","nickname":"","followerCount":"","domain":"","contact":""},"submited":false,"ranking":[]}},"republish":{}},"fetchHost":"www.zhihu.com","subAppName":"column"}</script><script src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/vendor.caa1c8048e4304e7b5ca.js.下载"></script><script src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/column.app.097c955d7a1df8435fcf.js.下载"></script><script src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/hm.js.下载" async=""></script><script src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/push.js.下载" async=""></script><script src="./😀前端入门操作系统知识，这一篇就够啦！ - 知乎_files/zap.js.下载"></script><div><div style="display: none;">想来知乎工作？请发送邮件到 jobs@zhihu.com</div></div><div><div><div class="css-8pdeid"></div></div></div><div><div><div class="Editable-languageSuggestions" style="left: -1179px; top: -999px;"><div><div class="Popover"><label class="Editable-languageSuggestionsInput Input-wrapper"><input autocomplete="off" role="combobox" aria-expanded="false" aria-autocomplete="list" aria-activedescendant="AutoComplete13-0" id="Popover12-toggle" aria-haspopup="true" aria-owns="Popover12-content" class="Input" placeholder="选择语言" value=""><svg class="Zi Zi--Select" fill="#afbdcf" viewBox="0 0 24 24" width="24" height="24"><path d="M12 16.183l2.716-2.966a.757.757 0 0 1 1.064.001.738.738 0 0 1 0 1.052l-3.247 3.512a.758.758 0 0 1-1.064 0L8.22 14.27a.738.738 0 0 1 0-1.052.758.758 0 0 1 1.063 0L12 16.183zm0-9.365L9.284 9.782a.758.758 0 0 1-1.064 0 .738.738 0 0 1 0-1.052l3.248-3.512a.758.758 0 0 1 1.065 0L15.78 8.73a.738.738 0 0 1 0 1.052.757.757 0 0 1-1.063.001L12 6.818z" fill-rule="evenodd"></path></svg></label></div></div></div></div></div></body></html>