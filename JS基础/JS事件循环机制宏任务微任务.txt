
	1. 首先同步任务和异步任务分别进入不同的执行“场所”，同步任务进入主线程异步任务进入Event Table 并注册函数
	2. 当Event Table中指定的事情完成时，会将这个函数移入Event Queue
	3. 主线程内的任务执行完毕为空，会去Event Queue 读取对应的函数，进入主线程执行
	4. 上面的过程会不断地重复也就是常说的事件循环Event Loop
	5. 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。

	JavaScript除了广义上的的同步任务何异步任务，其对任务还有更精细的定义：
　　　　macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
　　　　micro-task(微任务)：Promise，process.nextTick
　不同类型的任务会进入对应的Event Queue。
　事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。
	接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。
	
	JS单线程又是如何实现异步的呢？
		JS单线程指的是JS只有一个执行线程，同一时刻只有一段代码在执行
		是通过的事件循环(event loop)，理解了event loop机制，就理解了JS的执行机制
		JS的单线程是指一个浏览器进程中只有一个JS的执行线程，同一时刻内只会有一段代码在执行
		（你可以使用IE的标签式浏览试试看效果，这时打开的多个页面使用的都是同一个JS执行线程，
		如果其中一个页面在执行一个运算量较大的function时，其他窗口的JS就会停止工作）。
		而异步机制是浏览器的两个或以上常驻线程共同完成的，例如异步请求是由两个常驻线程：JS执行线程和事件触发线程共同完成的，
		JS的执行线程发起异步请求（这时浏览器会开一条新的HTTP请求线程来执行请求，这时JS的任务已完成，继续执行线程队列中剩下的其他任务），
		然后在未来的某一时刻事件触发线程监视到之前的发起的HTTP请求已完成，它就会把完成事件插入到JS执行队列的尾部等待JS处理。
		又例如定时触发（settimeout和setinterval）是由浏览器的定时器线程执行的定时计数，然后在定时时间把定时处理函数的执行请求插入到JS执行队列的尾端
		（所以用这两个函数的时候，实际的执行时间是大于或等于指定时间的，不保证能准确定时的）。
		所以，所谓的JS的单线程和异步更多的应该是属于浏览器的行为，他们之间没有冲突，更不是同一种事物，没有什么区别不区别的。


	