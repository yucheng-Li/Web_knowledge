前言：Reguler expression - 正则表达式
	它是 `查找` 和 `替换` 文本中的特殊字符的一种高效的手段

JavaScript中的正则：

	在 JavaScript 中，正则通常是被用在RegExp的exec和test方法以及 String的match、replace、search和split方法；
		exec		一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。
		test		一个在字符串中测试是否匹配的RegExp方法，它返回true或false。
		match	一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。
		search	一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。
		replace	一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。
		split		一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。
	
	注意：
	为什么exec()用g来匹配返回的不是一个数组？
	当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。
	这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。
	所以到底怎么用正则返回一个匹配成功的数组呢？
	答案是用match；
	eg: var myRe = /.b/g;
		  var array = "cdbbdbsbz".match(myRe)
	
1. 匹配单个字符
 
 # 匹配普通文本 #
 g  ~~匹配多个结果
 i  ~~不区分大小写进行搜索
 .  ~~匹配任意单个字符 （理解 .a.. 的含义）

	# 匹配特殊字符 #
 \  ~~转义字符 

2. 匹配一组字符
 
 [ ] ~~字符集合 ，eg: [ abc ] 匹配字符集合中的任意一个字符
 [ 0-9 ] ~~字符区间，eg: [ 0-9a-zA-Z] 区间中的任一字符 [ 0-9 ] 等同于[ 0123456789 ] 
 ^  ~~排除字符或字符集中的字符，[ ^0-9 ] ，只有它出现在字符集合里且紧跟左方括号 [ 后面的时候才表示排除该字符集合
 
3. 匹配元字符

空白字符 ：搭配转译字符 \ 来使用的空白元字符，
				 [ \b ] ：回退删除（Backspace）、\f ：换页符、\n ：换行符、\r ：回车符、\t ：制表符（Tab键）、\v ：垂直制表符
 \d ~~匹配任何一个数字字符 当然等同于 [ 0-9 ]  
 \D ~~匹配任何一个非数字字符 等同于 [ ^0-9 ]  
 \w ~~匹配任何一个字母数字字符（无论大小写）或下划线字符 _
 \W ~~匹配任何一个非字母数字字符（无论大小写）或下划线字符 _
 \s  ~~匹配任何一个空白字符（等价于[ \f \n \r \t \v ] ）
 \S  ~~匹配任何一个非空白字符（等价于[ ^\f \n \r \t \v ] ）
 \x  ~~使用十六进制值 eg: \x0A 对应ASCII字符10，也就是换行符等价于 \n
 \0  ~~使用八进制值 eg: \011 对应ASCII字符9，也就是换行符等价于 \t
 
4. 重复匹配

 + ~~匹配一个或多个字符（至少一个）
 *  ~~匹配零个或多个字符
 ？~~匹配零个或一个字符
 { 6 }  ~~匹配重复范围 \d { 6 } 匹配任一个数字重复 6 次8
 { 2，4}  ~~匹配区间范围 \d { 2，4 } 匹配任一个数字至少重复2次最多重复4次 
 { 3，}  ~~匹配“至少重复3次”
 *？ ~~防止过度匹配，* 和 + 都是贪婪型( greedy) 元字符匹配一段文本匹配开始就一直到末尾，且碰到一个匹配字符不会停下来
 
5. 位置匹配

 \b ~~边界 ， \b cat \b  表示一个单词的开始和结束，因为句子中单词的前后都有空格（空格是用来分隔单词的字符之一）
			因此若想要匹配一个完整的单词就必须要在这个单词的前后都加上\b
 \B ~~不匹配单词边界，也就是\B -\B 将匹配一个前后都不是单词边界的连字符
 ^  ~~匹配字符串开始的位置
 $  ~~匹配字符串结尾的位置
 
6. 使用子表达式

使用子表达式的目的：是为了将某连续的字符组合视为一个单一的实体来使用
 （）~~子表达式，eg: ( &nbsp;) { 2, } 等同于匹配 &nbsp;&nbsp; eg: ( /d{ 1, 3} \ . ) { 3 } \d{ 1, 3 }
 （( )）~~子表达式的嵌套，如下用子表达式的嵌套来匹配合法的IP地址 eg: (((25[0-5]) | (2[ 0-4 ]\d ) | ( 1\d{ 2 } ) | ( \d{ 1, 2})) \ . ) { 3 } (25[0-5]) | (2[ 0-4 ]\d ) | ( 1\d{ 2 } ) | ( \d{ 1, 2})) \ . )
	
7. 反向引用

 \1 ~~反向引用表示 \1 匹配的内容与第一个分组匹配的内容一样，“反向引用” 表示前一规则匹配的相同内容的重复
		注意：反向引用只能引用括号的里表达式 eg：<[ Hh ] ([ 1-6 ]) >.*?<\/[ Hh ] \1> 
		注意：反向引用中 \1代表第一个子表达式 \5代表第五个子表达式，\0 代表整个正则表达式
 \1 ~~反向引用应用在正则的替换操作，因为进行替换操作需要用到两个正则表达式，一个用来指定搜索模式，另一个
		用来指定替换模式，而反向引用是可以跨模式使用的
		eg: <a href=" mailto : \1">\1</a> \1 引用搜索模式匹配的内容，并应用反向引用将其替换成可点击的链接
 大小写转换：
	\E : 结束 \L或\U转换
	\l ：把下一个字符转换成小写 
	\L ：把 \L 到 \E 之间的字符全部转换成小写
	\u ：把下一个字符转换成大写 
	\U ：把 \U 到 \E 之间的字符全部转换成大写
	这些可以搭配子表达式和反向引用来使用有很好的效果， \1 \U \2 \E \3

8. 环视
		目的：用在更精确的控制匹配返回结果，可用在密码输入匹配
		学习地址：https://juejin.im/post/6844903638347825166
		(?=foo)		前瞻（lookahead）	判断紧跟在字符串中当前位置后面的内容是否是 foo

		(?!foo)		否定前瞻（negative lookahead）	判断紧跟在字符串中当前位置后面的内容是否不是 foo

		(?<=foo)		后视（lookbehind）	判断紧跟在字符串中当前位置前面的内容是否是 foo

		(?<!foo)		否定后视（negative lookbehind）	  判断紧跟在字符串中当前位置前面的内容是否不是 foo


 
 













